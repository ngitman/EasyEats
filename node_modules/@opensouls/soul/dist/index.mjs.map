{
  "version": 3,
  "sources": ["../src/soul.ts", "../src/sockets/soul-engine-socket.ts", "../src/content-streamer.ts", "../src/event-log.ts", "../src/tool-handler.ts"],
  "sourcesContent": ["/* eslint-disable perfectionist/sort-object-types */\n\nimport { DeveloperDispatchedPerception, EventLogDoc, InteractionRequest, Json, SoulEnvironment, SoulEvent, SoulEventKinds, debugChatShape } from '@opensouls/core'\nimport { HocuspocusProvider, HocuspocusProviderWebsocket } from \"@hocuspocus/provider\";\nimport { getYjsDoc, observeDeep, syncedStore } from \"@syncedstore/core\";\nimport { EventEmitter } from \"eventemitter3\";\nimport { v4 as uuidv4 } from 'uuid'\n\nimport { getConnectedWebsocket } from \"./sockets/soul-engine-socket.js\";\nimport { ContentStreamer } from \"./content-streamer.js\";\nimport { syncedEventStore } from \"./event-log.js\";\nimport { ToolHandler } from './tool-handler.js';\n// syntactic sugar for listening to actions which tend to be in the past tense\n// but allowing to listen to things like Action.SAYS\nexport enum Actions {\n  SAYS = \"says\",\n}\n\nexport type { InteractionRequest } from \"@opensouls/core\"\n\nexport enum Events {\n  // this one is sent by the server\n  newSoulEvent = \"newSoulEvent\",\n  // this one is used by developers\n  dispatchExternalPerception = \"dispatchExternalPerception\",\n  compileError = \"compileError\",\n  saveVersion = \"saveVersion\",\n  revertDoc = \"revertDoc\",\n  setEnvironment = \"setEnvironment\",\n\n  // these two are not used on the server\n  // @deprecated newPerception is deprecated, use newInteractionRequest\n  newPerception = \"newPerception\",\n  newInteractionRequest = \"newInteractionRequest\"\n}\n\nexport interface SoulOpts {\n  local?: boolean\n  organization: string\n  soulId?: string\n  blueprint: string\n  token?: string\n  version?: string\n  webSocket?: HocuspocusProviderWebsocket,\n  environment?: SoulEnvironment,\n  debug?: boolean\n}\n\nexport function said(entity: string, content: string): DeveloperDispatchedPerception {\n  return {\n    action: \"said\",\n    content,\n    name: entity,\n  }\n}\n\n/**\n * `ActionEvent` is designed to be isomorphic between streaming and non-streaming actions.\n * When an event is not streaming,\n * the `content` will be immediately available as a `Promise<string>`. The `stream`\n * will be an `AsyncIterable<string>` that yields a single value if the event\n * is not streaming, allowing for consistent handling of event data.\n * \n * If the event *is* streaming then content will resolve when the stream is complete.\n */\nexport type ActionEvent = {\n  content: () => Promise<string>\n  isStreaming: boolean\n  stream: () => AsyncIterable<string>\n  action: string\n  name?: string,\n  _metadata: InteractionRequest['_metadata']\n  _timestamp: InteractionRequest['_timestamp']\n\n  // @deprecated perception is deprecated, use interactionRequest\n  perception: InteractionRequest\n  interactionRequest: InteractionRequest\n}\n\nexport type SoulEvents = {\n  [K in Actions]: (evt: ActionEvent) => void\n} & {\n  [key: string]: (evt: ActionEvent) => void\n} & {\n  // @deprecated newPerception is deprecated, use newInteractionRequest instead.\n  newPerception: (evt: InteractionRequest) => void,\n  newInteractionRequest: (evt: InteractionRequest) => void,\n  newSoulEvent: (evt: SoulEvent) => void,\n}\n\n// eslint-disable-next-line unicorn/prefer-event-target\nexport class Soul extends EventEmitter<SoulEvents> {\n  soulId\n\n  private blueprint\n  private connection?: Awaited<ReturnType<Soul[\"getProvider\"]>>\n  private debug\n  private environment\n  private errorHandler: (error: Error) => void\n  private local: boolean\n  private organizationSlug\n  private selfCreatedWebsocket = false\n  private token\n  private version\n  private toolHandler: ToolHandler\n  \n  private websocket?: HocuspocusProviderWebsocket\n\n  constructor({\n    debug,\n    local,\n    organization,\n    soulId,\n    blueprint,\n    token,\n    version,\n    webSocket,\n    environment\n  }: SoulOpts) {\n    super()\n    if (debug && !token) {\n      throw new Error(\"you must use a token to enable debug chat\")\n    }\n\n    this.debug = debug\n    this.environment = environment\n    this.organizationSlug = organization\n    this.blueprint = blueprint\n    this.soulId = soulId || uuidv4()\n    this.local = Boolean(local)\n    this.token = token || \"anonymous\"\n    this.version = version || \"prod\"\n    if (webSocket) {\n      this.websocket = webSocket\n      this.connection = this.getProvider()\n    }\n\n    this.toolHandler = new ToolHandler(this)\n\n    this.errorHandler = (error) => {\n      console.warn(\"warning: error handler not registered. use onError() to catch errors.\")\n      throw error.message;\n    }\n  }\n\n  get events() {\n    if (!this.connection) {\n      throw new Error(\"You must call start() before accessing events\")\n    }\n\n    return this.connection.store.events\n  }\n\n  get store(): ReturnType<typeof syncedEventStore> {\n    if (!this.connection) {\n      throw new Error(\"You must call start() before accessing the store\")\n    }\n\n    this.connection.store.pendingToolCalls ||= {}\n\n    return this.connection.store\n  }\n\n  get connected() {\n    return this.connection?.provider.isConnected\n  }\n\n  async connect(): Promise<string> {\n    if (this.connection) {\n      console.warn(\"connect() called twice on soul\")\n      return this.soulId\n    }\n    if (!this.websocket) {\n      this.selfCreatedWebsocket = true\n      // eslint-disable-next-line unicorn/no-typeof-undefined\n      if (typeof (globalThis.WebSocket) === \"undefined\") {\n        const { default: ws } = await import(\"ws\");\n        this.websocket = getConnectedWebsocket(this.organizationSlug, this.local, Boolean(this.debug), { WebSocketPolyfill: ws })\n      } else {\n        this.websocket = getConnectedWebsocket(this.organizationSlug, this.local, Boolean(this.debug))\n      }\n    }\n\n    // we need to do this a 2nd time because of the await above in the this.websocket block\n    if (this.connection) {\n      console.warn(\"connect() called twice on soul\")\n      return this.soulId\n    }\n\n    this.connection = this.getProvider()\n    if (this.debug) {\n      console.log(\"CONNECTED TO SOUL. DEBUG HERE:\", this.debugUrl())\n    }\n\n    this.toolHandler.start()\n\n    return this.soulId\n  }\n\n  async disconnect() {\n    if (!this.connection) {\n      throw new Error(\"You must call start() before stopping\")\n    }\n\n    this.toolHandler.stop()\n\n    const { provider } = this.connection\n    provider.destroy()\n    // the provider does not destroy the websocket connection\n    if (this.selfCreatedWebsocket) {\n      provider.configuration.websocketProvider.destroy()\n    }\n\n    this.connection = undefined\n\n    this.removeAllListeners()\n  }\n\n  async reset() {\n    if (!this.connection) {\n      throw new Error(\"You must call start() before stopping\")\n    }\n\n    if (!this.debug) {\n      throw new Error(\"You can only reset in debug mode\")\n    }\n\n    const { provider } = this.connection\n    provider.sendStateless(JSON.stringify({\n      event: Events.revertDoc,\n      data: {\n        version: \"initial\",\n      }\n    }))\n  }\n\n  registerTool<Params = Json, Response = Json>(tool: string, handler: (params: Params) => Promise<Response>) {\n    return this.toolHandler.registerTool(tool, handler)\n  }\n\n  async dispatch(perception: DeveloperDispatchedPerception) {\n    if (!this.connection) {\n      throw new Error(\"You must call start() before saying anything\")\n    }\n\n    const { provider } = this.connection\n    provider.sendStateless(JSON.stringify({\n      event: Events.dispatchExternalPerception,\n      data: {\n        perception,\n      }\n    }))\n  }\n\n  onError(handler: (error: Error) => void) {\n    this.errorHandler = handler\n  }\n\n  setEnvironment(environment: SoulEnvironment) {\n    if (!this.connection) {\n      throw new Error(\"You must call start() before setting environment\")\n    }\n\n    this.environment = environment\n\n    const { provider } = this.connection\n    provider.sendStateless(JSON.stringify({\n      event: Events.setEnvironment,\n      data: {\n        environment: this.environment,\n      }\n    }))\n  }\n\n  private actionEventFromInteractionRequest(interactionRequest: InteractionRequest): ActionEvent {\n    const partialActionEvent = {\n      name: interactionRequest.name,\n      action: interactionRequest.action,\n      _metadata: interactionRequest._metadata,\n      _timestamp: interactionRequest._timestamp,\n\n      // @perception is deprecated, use interactionRequest instead\n      perception: interactionRequest,\n      interactionRequest,\n    }\n    if (!interactionRequest._metadata?.streaming) {\n      return {\n        content: () => Promise.resolve(interactionRequest.content),\n        async *stream() {\n          yield interactionRequest.content\n        },\n        isStreaming: false,\n        ...partialActionEvent,\n      }\n    }\n\n    if (!this.connection) {\n      throw new Error('received stateless event before connection was established')\n    }\n\n    if (!interactionRequest) {\n      throw new Error(\"received a stateless message for an event that doesn't exist\")\n    }\n\n    try {\n      const streamer = new ContentStreamer()\n\n      const streamCompletePromise = new Promise<void>((resolve) => {\n        streamer.onComplete(resolve)\n      })\n\n      const disposer = observeDeep(interactionRequest, () => {\n        streamer.updateContent(interactionRequest.content)\n        if (interactionRequest._metadata?.streamComplete) {\n          disposer()\n          streamer.complete()\n          return\n        }\n      })\n\n      return {\n        async content() {\n          await streamCompletePromise\n          return interactionRequest.content\n        },\n        stream() { return streamer.stream() },\n        isStreaming: true,\n        ...partialActionEvent,\n      }\n    } catch (error: any) {\n      console.error(\"error setting up stream:\", error)\n      throw error\n    }\n  }\n\n  private debugUrl() {\n    const host = this.local ? \"http://localhost:3000\" : \"https://souls.chat\"\n    return `${host}/chats/${this.organizationSlug}/${this.blueprint}/${this.soulId}`\n  }\n\n  private eventFromPayload(payload: string): { event: SoulEvent, eventType: string } {\n    if (!this.connection) {\n      throw new Error(\"You must call start() before handling messages\")\n    }\n\n    const { data, event: eventType } = JSON.parse(payload) as { data: any, event: string }\n\n    return {\n      eventType,\n      event: data,\n    }\n  }\n\n  private getProvider() {\n    if (!this.websocket) {\n      throw new Error(\"you must specify a websocket before using getProvider. You can pass one, or start will handle it for you.\")\n    }\n\n    const store = this.debug ? syncedStore(debugChatShape) :  syncedEventStore()\n\n    const docName = this.debug ?\n      `debug-chat.${this.organizationSlug}.${this.blueprint}.${this.soulId}` :\n      `soul-session.${this.organizationSlug}.${this.blueprint}.${this.soulId}.${this.version}`\n\n    const provider = new HocuspocusProvider({\n      document: getYjsDoc(store),\n      name: docName,\n      async onAuthenticationFailed({ reason }) {\n        console.error(\"authentication failed\", reason)\n      },\n      onStateless: ({ payload }) => this.handleStatelessMessage(payload),\n      token: this.token,\n      websocketProvider: this.websocket,\n    });\n\n    provider.sendStateless(JSON.stringify({\n      event: Events.setEnvironment,\n      data: {\n        environment: this.environment,\n      }\n    }))\n\n    return {\n      provider,\n      store: this.debug ? (store as typeof debugChatShape).eventLog as EventLogDoc : (store as EventLogDoc),\n    }\n  }\n\n  private async handleStatelessMessage(payload: string) {\n    const { eventType, event: statelessEvent } = this.eventFromPayload(payload)\n    if (eventType !== Events.newSoulEvent) {\n      return // for now we only care about soul events\n    }\n\n    // first we will emit a SoulEvent so that the dev has full access to all the information\n    // then we will emit a specific Perception that is more convenient for the dev to use\n    // and also an action event which handles streaming for the developer.\n\n    this.emit(Events.newSoulEvent, statelessEvent)\n\n    if (statelessEvent._metadata?.type === \"error\") {\n      const uncaughtError = new Error(statelessEvent.content);\n      this.errorHandler(uncaughtError)\n      return;\n    }\n\n    try {\n      if (statelessEvent._kind !== SoulEventKinds.InteractionRequest) {\n        return // we only want to emit events *from* the soul, not the user events.\n      }\n\n      const interactionRequest = statelessEvent as InteractionRequest\n\n      if (!this.connection) {\n        throw new Error(\"missing connection on handleStatelessMessage\")\n      }\n\n      // now we want to get the auto-updating event from the actual document not the one broadcast stateless\n      const event = this.connection.store.events.find((event) => event._id === statelessEvent._id)\n      if (!event) {\n        throw new Error(\"received stateless event without a corresponding event in the document\")\n      }\n\n      this.emit(Events.newPerception, interactionRequest)\n      // allow any custom actions to also have their content turned into a stream if desired by the developer.\n      this.emit(event.action, this.actionEventFromInteractionRequest(event as InteractionRequest))\n\n      return\n    } catch (error) {\n      console.error(\"error handling event:\", error)\n      throw error\n    }\n  }\n}\n", "import { HocuspocusProviderWebsocket, HocuspocusProviderWebsocketConfiguration } from \"@hocuspocus/provider\"\n\nexport const websocketUrl = (organizationSlug: string, local: boolean, debug: boolean) => {\n  const urlpath = debug ? \"debug-chat\" : \"experience\"\n\n  return local ?\n    `ws://localhost:4000/${organizationSlug}/${urlpath}` :\n    `wss://servers.souls.chat/${organizationSlug}/${urlpath}`\n}\n\nexport const getConnectedWebsocket = (\n  organizationSlug: string,\n  local: boolean,\n  debug: boolean, \n  opts: Partial<HocuspocusProviderWebsocketConfiguration> = {}\n) => new HocuspocusProviderWebsocket({\n    url: websocketUrl(organizationSlug, local, debug),\n    ...opts,\n  })\n", "\n/**\n * This class handles a string that is constantly being updated, and turns it into an async iterable that streams the *new* content\n * instead of the whole string.\n */\nexport class ContentStreamer {\n  private _onComplete: (() => void) | null = null;\n  private alreadyStreamedContent = \"\"\n  private currentContent = \"\";\n\n  private finished = false\n\n  private resolveUpdatePromise: (() => void) | null = null;\n\n  complete() {\n    this.finished = true\n    if (this.resolveUpdatePromise) {\n      this.resolveUpdatePromise();\n      this.resolveUpdatePromise = null;\n    }\n\n    if (this._onComplete) {\n      this._onComplete();\n    }\n  }\n\n  onComplete(callback: () => void) {\n    this._onComplete = callback;\n  }\n\n  async *stream() {\n    while (!this.finished) {\n      // Stream any remaining content even if finished is true\n      const contentToStream = this.contentToStream();\n      if (contentToStream.length > 0) {\n        const message = contentToStream;\n        yield message;\n        this.alreadyStreamedContent += message;\n      } else if (!this.finished) {\n        // Only wait for new content if we are not finished\n        // eslint-disable-next-line no-await-in-loop\n        await new Promise<void>(resolve => { this.resolveUpdatePromise = resolve; });\n      }\n    }\n\n    // If we are finished, stream the last bit of content\n    const contentToStream = this.contentToStream();\n    if (contentToStream.length > 0) {\n      const message = contentToStream;\n      yield message;\n      this.alreadyStreamedContent += message;\n    }\n\n    if (this.resolveUpdatePromise) {\n      this.resolveUpdatePromise();\n      this.resolveUpdatePromise = null;\n    }\n  }\n\n  updateContent(message: string) {\n    this.currentContent = message;\n    if (this.resolveUpdatePromise) {\n      this.resolveUpdatePromise();\n      this.resolveUpdatePromise = null;\n    }\n  }\n\n  private contentToStream(): string {\n    return this.currentContent.slice(this.alreadyStreamedContent.length);\n  }\n}\n", "import { syncedStore } from \"@syncedstore/core\"\n\nimport { eventLogShape, type EventLogDoc } from \"@opensouls/core\"\n\nexport const syncedEventStore = \n  (): ReturnType<typeof syncedStore<EventLogDoc>> => syncedStore<EventLogDoc>(eventLogShape)\n", "import { Json, JsonRPCCall, JsonRPCResponse } from \"@opensouls/core\";\nimport { Soul } from \"./soul.js\";\nimport { observeDeep } from \"@syncedstore/core\";\n\nexport class ToolHandler {\n  private tools: Record<string, (params: any) => Promise<any>> = {};\n  \n  private inProgress: Set<string>;\n\n  private stopObserving?: () => void;\n\n  constructor(private soul: Soul) {\n    this.inProgress = new Set();\n  }\n\n  registerTool<Params = Json, Response = Json>(tool: string, handler: (params: Params) => Promise<Response>) {\n    this.tools[tool] = handler;\n  }\n\n  start() {\n    this.stopObserving = observeDeep(this.soul.store, () => {\n      const pending = Object.entries(this.soul.store.pendingToolCalls ?? {}).filter(\n        (entry): entry is [string, { request: JsonRPCCall; response?: JsonRPCResponse }] => {\n          const { request, response } = entry[1] || {};\n          if (!request) {\n            return false;\n          }\n          if (response) {\n            return false\n          }\n          if (this.inProgress.has(request.id)) {\n            return false;\n          }\n          if (!this.tools[request.method]) {\n            console.warn(\"Soul tried to call\", request.method, \"but this tool is not registered.\")\n            return false;\n          }\n          return true;\n        }\n      );\n\n      for (const [, { request }] of pending) {\n        this.inProgress.add(request.id);\n        this.executeTool(request).finally(() => {\n          this.inProgress.delete(request.id);\n        })\n      }\n      \n    })\n  }\n\n  stop() {\n    this.stopObserving?.();\n  }\n\n  private async executeTool(request: JsonRPCCall) {\n    try {\n      const toolHandler = this.tools[request.method];\n      if (!toolHandler) {\n        throw {\n          code: 404,\n          message: \"Method not found\"\n        }\n      }\n      const result = await toolHandler(request.params);\n      this.soul.store.pendingToolCalls![request.id]!.response = {\n        id: request.id,\n        result,\n      };\n    } catch (err: any) {\n      this.soul.store.pendingToolCalls![request.id]!.response = {\n        error: {\n          code: err.code || -32000,\n          message: err.message || \"Internal error\",\n          data: err.data || null,\n        },\n        id: request.id,\n      }\n    }\n  }\n}"],
  "mappings": ";AAEA,SAA2G,gBAAgB,sBAAsB;AACjJ,SAAS,0BAAuD;AAChE,SAAS,WAAW,eAAAA,cAAa,eAAAC,oBAAmB;AACpD,SAAS,oBAAoB;AAC7B,SAAS,MAAM,cAAc;;;ACN7B,SAAS,mCAA6E;AAE/E,IAAM,eAAe,CAAC,kBAA0B,OAAgB,UAAmB;AACxF,QAAM,UAAU,QAAQ,eAAe;AAEvC,SAAO,QACL,uBAAuB,gBAAgB,IAAI,OAAO,KAClD,4BAA4B,gBAAgB,IAAI,OAAO;AAC3D;AAEO,IAAM,wBAAwB,CACnC,kBACA,OACA,OACA,OAA0D,CAAC,MACxD,IAAI,4BAA4B;AAAA,EACjC,KAAK,aAAa,kBAAkB,OAAO,KAAK;AAAA,EAChD,GAAG;AACL,CAAC;;;ACbI,IAAM,kBAAN,MAAsB;AAAA,EAAtB;AACL,SAAQ,cAAmC;AAC3C,SAAQ,yBAAyB;AACjC,SAAQ,iBAAiB;AAEzB,SAAQ,WAAW;AAEnB,SAAQ,uBAA4C;AAAA;AAAA,EAEpD,WAAW;AACT,SAAK,WAAW;AAChB,QAAI,KAAK,sBAAsB;AAC7B,WAAK,qBAAqB;AAC1B,WAAK,uBAAuB;AAAA,IAC9B;AAEA,QAAI,KAAK,aAAa;AACpB,WAAK,YAAY;AAAA,IACnB;AAAA,EACF;AAAA,EAEA,WAAW,UAAsB;AAC/B,SAAK,cAAc;AAAA,EACrB;AAAA,EAEA,OAAO,SAAS;AACd,WAAO,CAAC,KAAK,UAAU;AAErB,YAAMC,mBAAkB,KAAK,gBAAgB;AAC7C,UAAIA,iBAAgB,SAAS,GAAG;AAC9B,cAAM,UAAUA;AAChB,cAAM;AACN,aAAK,0BAA0B;AAAA,MACjC,WAAW,CAAC,KAAK,UAAU;AAGzB,cAAM,IAAI,QAAc,aAAW;AAAE,eAAK,uBAAuB;AAAA,QAAS,CAAC;AAAA,MAC7E;AAAA,IACF;AAGA,UAAM,kBAAkB,KAAK,gBAAgB;AAC7C,QAAI,gBAAgB,SAAS,GAAG;AAC9B,YAAM,UAAU;AAChB,YAAM;AACN,WAAK,0BAA0B;AAAA,IACjC;AAEA,QAAI,KAAK,sBAAsB;AAC7B,WAAK,qBAAqB;AAC1B,WAAK,uBAAuB;AAAA,IAC9B;AAAA,EACF;AAAA,EAEA,cAAc,SAAiB;AAC7B,SAAK,iBAAiB;AACtB,QAAI,KAAK,sBAAsB;AAC7B,WAAK,qBAAqB;AAC1B,WAAK,uBAAuB;AAAA,IAC9B;AAAA,EACF;AAAA,EAEQ,kBAA0B;AAChC,WAAO,KAAK,eAAe,MAAM,KAAK,uBAAuB,MAAM;AAAA,EACrE;AACF;;;ACtEA,SAAS,mBAAmB;AAE5B,SAAS,qBAAuC;AAEzC,IAAM,mBACX,MAAmD,YAAyB,aAAa;;;ACH3F,SAAS,mBAAmB;AAErB,IAAM,cAAN,MAAkB;AAAA,EAOvB,YAAoB,MAAY;AAAZ;AANpB,SAAQ,QAAuD,CAAC;AAO9D,SAAK,aAAa,oBAAI,IAAI;AAAA,EAC5B;AAAA,EAEA,aAA6C,MAAc,SAAgD;AACzG,SAAK,MAAM,IAAI,IAAI;AAAA,EACrB;AAAA,EAEA,QAAQ;AACN,SAAK,gBAAgB,YAAY,KAAK,KAAK,OAAO,MAAM;AACtD,YAAM,UAAU,OAAO,QAAQ,KAAK,KAAK,MAAM,oBAAoB,CAAC,CAAC,EAAE;AAAA,QACrE,CAAC,UAAmF;AAClF,gBAAM,EAAE,SAAS,SAAS,IAAI,MAAM,CAAC,KAAK,CAAC;AAC3C,cAAI,CAAC,SAAS;AACZ,mBAAO;AAAA,UACT;AACA,cAAI,UAAU;AACZ,mBAAO;AAAA,UACT;AACA,cAAI,KAAK,WAAW,IAAI,QAAQ,EAAE,GAAG;AACnC,mBAAO;AAAA,UACT;AACA,cAAI,CAAC,KAAK,MAAM,QAAQ,MAAM,GAAG;AAC/B,oBAAQ,KAAK,sBAAsB,QAAQ,QAAQ,kCAAkC;AACrF,mBAAO;AAAA,UACT;AACA,iBAAO;AAAA,QACT;AAAA,MACF;AAEA,iBAAW,CAAC,EAAE,EAAE,QAAQ,CAAC,KAAK,SAAS;AACrC,aAAK,WAAW,IAAI,QAAQ,EAAE;AAC9B,aAAK,YAAY,OAAO,EAAE,QAAQ,MAAM;AACtC,eAAK,WAAW,OAAO,QAAQ,EAAE;AAAA,QACnC,CAAC;AAAA,MACH;AAAA,IAEF,CAAC;AAAA,EACH;AAAA,EAEA,OAAO;AACL,SAAK,gBAAgB;AAAA,EACvB;AAAA,EAEA,MAAc,YAAY,SAAsB;AAC9C,QAAI;AACF,YAAM,cAAc,KAAK,MAAM,QAAQ,MAAM;AAC7C,UAAI,CAAC,aAAa;AAChB,cAAM;AAAA,UACJ,MAAM;AAAA,UACN,SAAS;AAAA,QACX;AAAA,MACF;AACA,YAAM,SAAS,MAAM,YAAY,QAAQ,MAAM;AAC/C,WAAK,KAAK,MAAM,iBAAkB,QAAQ,EAAE,EAAG,WAAW;AAAA,QACxD,IAAI,QAAQ;AAAA,QACZ;AAAA,MACF;AAAA,IACF,SAAS,KAAU;AACjB,WAAK,KAAK,MAAM,iBAAkB,QAAQ,EAAE,EAAG,WAAW;AAAA,QACxD,OAAO;AAAA,UACL,MAAM,IAAI,QAAQ;AAAA,UAClB,SAAS,IAAI,WAAW;AAAA,UACxB,MAAM,IAAI,QAAQ;AAAA,QACpB;AAAA,QACA,IAAI,QAAQ;AAAA,MACd;AAAA,IACF;AAAA,EACF;AACF;;;AJlEO,IAAK,UAAL,kBAAKC,aAAL;AACL,EAAAA,SAAA,UAAO;AADG,SAAAA;AAAA,GAAA;AAML,IAAK,SAAL,kBAAKC,YAAL;AAEL,EAAAA,QAAA,kBAAe;AAEf,EAAAA,QAAA,gCAA6B;AAC7B,EAAAA,QAAA,kBAAe;AACf,EAAAA,QAAA,iBAAc;AACd,EAAAA,QAAA,eAAY;AACZ,EAAAA,QAAA,oBAAiB;AAIjB,EAAAA,QAAA,mBAAgB;AAChB,EAAAA,QAAA,2BAAwB;AAbd,SAAAA;AAAA,GAAA;AA4BL,SAAS,KAAK,QAAgB,SAAgD;AACnF,SAAO;AAAA,IACL,QAAQ;AAAA,IACR;AAAA,IACA,MAAM;AAAA,EACR;AACF;AAqCO,IAAM,OAAN,cAAmB,aAAyB;AAAA,EAiBjD,YAAY;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAAa;AACX,UAAM;AAlBR,SAAQ,uBAAuB;AAmB7B,QAAI,SAAS,CAAC,OAAO;AACnB,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAC7D;AAEA,SAAK,QAAQ;AACb,SAAK,cAAc;AACnB,SAAK,mBAAmB;AACxB,SAAK,YAAY;AACjB,SAAK,SAAS,UAAU,OAAO;AAC/B,SAAK,QAAQ,QAAQ,KAAK;AAC1B,SAAK,QAAQ,SAAS;AACtB,SAAK,UAAU,WAAW;AAC1B,QAAI,WAAW;AACb,WAAK,YAAY;AACjB,WAAK,aAAa,KAAK,YAAY;AAAA,IACrC;AAEA,SAAK,cAAc,IAAI,YAAY,IAAI;AAEvC,SAAK,eAAe,CAAC,UAAU;AAC7B,cAAQ,KAAK,uEAAuE;AACpF,YAAM,MAAM;AAAA,IACd;AAAA,EACF;AAAA,EAEA,IAAI,SAAS;AACX,QAAI,CAAC,KAAK,YAAY;AACpB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAEA,WAAO,KAAK,WAAW,MAAM;AAAA,EAC/B;AAAA,EAEA,IAAI,QAA6C;AAC/C,QAAI,CAAC,KAAK,YAAY;AACpB,YAAM,IAAI,MAAM,kDAAkD;AAAA,IACpE;AAEA,SAAK,WAAW,MAAM,qBAAqB,CAAC;AAE5C,WAAO,KAAK,WAAW;AAAA,EACzB;AAAA,EAEA,IAAI,YAAY;AACd,WAAO,KAAK,YAAY,SAAS;AAAA,EACnC;AAAA,EAEA,MAAM,UAA2B;AAC/B,QAAI,KAAK,YAAY;AACnB,cAAQ,KAAK,gCAAgC;AAC7C,aAAO,KAAK;AAAA,IACd;AACA,QAAI,CAAC,KAAK,WAAW;AACnB,WAAK,uBAAuB;AAE5B,UAAI,OAAQ,WAAW,cAAe,aAAa;AACjD,cAAM,EAAE,SAAS,GAAG,IAAI,MAAM,OAAO,IAAI;AACzC,aAAK,YAAY,sBAAsB,KAAK,kBAAkB,KAAK,OAAO,QAAQ,KAAK,KAAK,GAAG,EAAE,mBAAmB,GAAG,CAAC;AAAA,MAC1H,OAAO;AACL,aAAK,YAAY,sBAAsB,KAAK,kBAAkB,KAAK,OAAO,QAAQ,KAAK,KAAK,CAAC;AAAA,MAC/F;AAAA,IACF;AAGA,QAAI,KAAK,YAAY;AACnB,cAAQ,KAAK,gCAAgC;AAC7C,aAAO,KAAK;AAAA,IACd;AAEA,SAAK,aAAa,KAAK,YAAY;AACnC,QAAI,KAAK,OAAO;AACd,cAAQ,IAAI,kCAAkC,KAAK,SAAS,CAAC;AAAA,IAC/D;AAEA,SAAK,YAAY,MAAM;AAEvB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,MAAM,aAAa;AACjB,QAAI,CAAC,KAAK,YAAY;AACpB,YAAM,IAAI,MAAM,uCAAuC;AAAA,IACzD;AAEA,SAAK,YAAY,KAAK;AAEtB,UAAM,EAAE,SAAS,IAAI,KAAK;AAC1B,aAAS,QAAQ;AAEjB,QAAI,KAAK,sBAAsB;AAC7B,eAAS,cAAc,kBAAkB,QAAQ;AAAA,IACnD;AAEA,SAAK,aAAa;AAElB,SAAK,mBAAmB;AAAA,EAC1B;AAAA,EAEA,MAAM,QAAQ;AACZ,QAAI,CAAC,KAAK,YAAY;AACpB,YAAM,IAAI,MAAM,uCAAuC;AAAA,IACzD;AAEA,QAAI,CAAC,KAAK,OAAO;AACf,YAAM,IAAI,MAAM,kCAAkC;AAAA,IACpD;AAEA,UAAM,EAAE,SAAS,IAAI,KAAK;AAC1B,aAAS,cAAc,KAAK,UAAU;AAAA,MACpC,OAAO;AAAA,MACP,MAAM;AAAA,QACJ,SAAS;AAAA,MACX;AAAA,IACF,CAAC,CAAC;AAAA,EACJ;AAAA,EAEA,aAA6C,MAAc,SAAgD;AACzG,WAAO,KAAK,YAAY,aAAa,MAAM,OAAO;AAAA,EACpD;AAAA,EAEA,MAAM,SAAS,YAA2C;AACxD,QAAI,CAAC,KAAK,YAAY;AACpB,YAAM,IAAI,MAAM,8CAA8C;AAAA,IAChE;AAEA,UAAM,EAAE,SAAS,IAAI,KAAK;AAC1B,aAAS,cAAc,KAAK,UAAU;AAAA,MACpC,OAAO;AAAA,MACP,MAAM;AAAA,QACJ;AAAA,MACF;AAAA,IACF,CAAC,CAAC;AAAA,EACJ;AAAA,EAEA,QAAQ,SAAiC;AACvC,SAAK,eAAe;AAAA,EACtB;AAAA,EAEA,eAAe,aAA8B;AAC3C,QAAI,CAAC,KAAK,YAAY;AACpB,YAAM,IAAI,MAAM,kDAAkD;AAAA,IACpE;AAEA,SAAK,cAAc;AAEnB,UAAM,EAAE,SAAS,IAAI,KAAK;AAC1B,aAAS,cAAc,KAAK,UAAU;AAAA,MACpC,OAAO;AAAA,MACP,MAAM;AAAA,QACJ,aAAa,KAAK;AAAA,MACpB;AAAA,IACF,CAAC,CAAC;AAAA,EACJ;AAAA,EAEQ,kCAAkC,oBAAqD;AAC7F,UAAM,qBAAqB;AAAA,MACzB,MAAM,mBAAmB;AAAA,MACzB,QAAQ,mBAAmB;AAAA,MAC3B,WAAW,mBAAmB;AAAA,MAC9B,YAAY,mBAAmB;AAAA;AAAA,MAG/B,YAAY;AAAA,MACZ;AAAA,IACF;AACA,QAAI,CAAC,mBAAmB,WAAW,WAAW;AAC5C,aAAO;AAAA,QACL,SAAS,MAAM,QAAQ,QAAQ,mBAAmB,OAAO;AAAA,QACzD,OAAO,SAAS;AACd,gBAAM,mBAAmB;AAAA,QAC3B;AAAA,QACA,aAAa;AAAA,QACb,GAAG;AAAA,MACL;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,YAAY;AACpB,YAAM,IAAI,MAAM,4DAA4D;AAAA,IAC9E;AAEA,QAAI,CAAC,oBAAoB;AACvB,YAAM,IAAI,MAAM,8DAA8D;AAAA,IAChF;AAEA,QAAI;AACF,YAAM,WAAW,IAAI,gBAAgB;AAErC,YAAM,wBAAwB,IAAI,QAAc,CAAC,YAAY;AAC3D,iBAAS,WAAW,OAAO;AAAA,MAC7B,CAAC;AAED,YAAM,WAAWC,aAAY,oBAAoB,MAAM;AACrD,iBAAS,cAAc,mBAAmB,OAAO;AACjD,YAAI,mBAAmB,WAAW,gBAAgB;AAChD,mBAAS;AACT,mBAAS,SAAS;AAClB;AAAA,QACF;AAAA,MACF,CAAC;AAED,aAAO;AAAA,QACL,MAAM,UAAU;AACd,gBAAM;AACN,iBAAO,mBAAmB;AAAA,QAC5B;AAAA,QACA,SAAS;AAAE,iBAAO,SAAS,OAAO;AAAA,QAAE;AAAA,QACpC,aAAa;AAAA,QACb,GAAG;AAAA,MACL;AAAA,IACF,SAAS,OAAY;AACnB,cAAQ,MAAM,4BAA4B,KAAK;AAC/C,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEQ,WAAW;AACjB,UAAM,OAAO,KAAK,QAAQ,0BAA0B;AACpD,WAAO,GAAG,IAAI,UAAU,KAAK,gBAAgB,IAAI,KAAK,SAAS,IAAI,KAAK,MAAM;AAAA,EAChF;AAAA,EAEQ,iBAAiB,SAA0D;AACjF,QAAI,CAAC,KAAK,YAAY;AACpB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AAEA,UAAM,EAAE,MAAM,OAAO,UAAU,IAAI,KAAK,MAAM,OAAO;AAErD,WAAO;AAAA,MACL;AAAA,MACA,OAAO;AAAA,IACT;AAAA,EACF;AAAA,EAEQ,cAAc;AACpB,QAAI,CAAC,KAAK,WAAW;AACnB,YAAM,IAAI,MAAM,2GAA2G;AAAA,IAC7H;AAEA,UAAM,QAAQ,KAAK,QAAQC,aAAY,cAAc,IAAK,iBAAiB;AAE3E,UAAM,UAAU,KAAK,QACnB,cAAc,KAAK,gBAAgB,IAAI,KAAK,SAAS,IAAI,KAAK,MAAM,KACpE,gBAAgB,KAAK,gBAAgB,IAAI,KAAK,SAAS,IAAI,KAAK,MAAM,IAAI,KAAK,OAAO;AAExF,UAAM,WAAW,IAAI,mBAAmB;AAAA,MACtC,UAAU,UAAU,KAAK;AAAA,MACzB,MAAM;AAAA,MACN,MAAM,uBAAuB,EAAE,OAAO,GAAG;AACvC,gBAAQ,MAAM,yBAAyB,MAAM;AAAA,MAC/C;AAAA,MACA,aAAa,CAAC,EAAE,QAAQ,MAAM,KAAK,uBAAuB,OAAO;AAAA,MACjE,OAAO,KAAK;AAAA,MACZ,mBAAmB,KAAK;AAAA,IAC1B,CAAC;AAED,aAAS,cAAc,KAAK,UAAU;AAAA,MACpC,OAAO;AAAA,MACP,MAAM;AAAA,QACJ,aAAa,KAAK;AAAA,MACpB;AAAA,IACF,CAAC,CAAC;AAEF,WAAO;AAAA,MACL;AAAA,MACA,OAAO,KAAK,QAAS,MAAgC,WAA2B;AAAA,IAClF;AAAA,EACF;AAAA,EAEA,MAAc,uBAAuB,SAAiB;AACpD,UAAM,EAAE,WAAW,OAAO,eAAe,IAAI,KAAK,iBAAiB,OAAO;AAC1E,QAAI,cAAc,mCAAqB;AACrC;AAAA,IACF;AAMA,SAAK,KAAK,mCAAqB,cAAc;AAE7C,QAAI,eAAe,WAAW,SAAS,SAAS;AAC9C,YAAM,gBAAgB,IAAI,MAAM,eAAe,OAAO;AACtD,WAAK,aAAa,aAAa;AAC/B;AAAA,IACF;AAEA,QAAI;AACF,UAAI,eAAe,UAAU,eAAe,oBAAoB;AAC9D;AAAA,MACF;AAEA,YAAM,qBAAqB;AAE3B,UAAI,CAAC,KAAK,YAAY;AACpB,cAAM,IAAI,MAAM,8CAA8C;AAAA,MAChE;AAGA,YAAM,QAAQ,KAAK,WAAW,MAAM,OAAO,KAAK,CAACC,WAAUA,OAAM,QAAQ,eAAe,GAAG;AAC3F,UAAI,CAAC,OAAO;AACV,cAAM,IAAI,MAAM,wEAAwE;AAAA,MAC1F;AAEA,WAAK,KAAK,qCAAsB,kBAAkB;AAElD,WAAK,KAAK,MAAM,QAAQ,KAAK,kCAAkC,KAA2B,CAAC;AAE3F;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,yBAAyB,KAAK;AAC5C,YAAM;AAAA,IACR;AAAA,EACF;AACF;",
  "names": ["observeDeep", "syncedStore", "contentToStream", "Actions", "Events", "observeDeep", "syncedStore", "event"]
}
