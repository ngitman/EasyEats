// src/soul.ts
import { SoulEventKinds, debugChatShape } from "@opensouls/core";
import { HocuspocusProvider } from "@hocuspocus/provider";
import { getYjsDoc, observeDeep as observeDeep2, syncedStore as syncedStore2 } from "@syncedstore/core";
import { EventEmitter } from "eventemitter3";
import { v4 as uuidv4 } from "uuid";

// src/sockets/soul-engine-socket.ts
import { HocuspocusProviderWebsocket } from "@hocuspocus/provider";
var websocketUrl = (organizationSlug, local, debug) => {
  const urlpath = debug ? "debug-chat" : "experience";
  return local ? `ws://localhost:4000/${organizationSlug}/${urlpath}` : `wss://servers.souls.chat/${organizationSlug}/${urlpath}`;
};
var getConnectedWebsocket = (organizationSlug, local, debug, opts = {}) => new HocuspocusProviderWebsocket({
  url: websocketUrl(organizationSlug, local, debug),
  ...opts
});

// src/content-streamer.ts
var ContentStreamer = class {
  constructor() {
    this._onComplete = null;
    this.alreadyStreamedContent = "";
    this.currentContent = "";
    this.finished = false;
    this.resolveUpdatePromise = null;
  }
  complete() {
    this.finished = true;
    if (this.resolveUpdatePromise) {
      this.resolveUpdatePromise();
      this.resolveUpdatePromise = null;
    }
    if (this._onComplete) {
      this._onComplete();
    }
  }
  onComplete(callback) {
    this._onComplete = callback;
  }
  async *stream() {
    while (!this.finished) {
      const contentToStream2 = this.contentToStream();
      if (contentToStream2.length > 0) {
        const message = contentToStream2;
        yield message;
        this.alreadyStreamedContent += message;
      } else if (!this.finished) {
        await new Promise((resolve) => {
          this.resolveUpdatePromise = resolve;
        });
      }
    }
    const contentToStream = this.contentToStream();
    if (contentToStream.length > 0) {
      const message = contentToStream;
      yield message;
      this.alreadyStreamedContent += message;
    }
    if (this.resolveUpdatePromise) {
      this.resolveUpdatePromise();
      this.resolveUpdatePromise = null;
    }
  }
  updateContent(message) {
    this.currentContent = message;
    if (this.resolveUpdatePromise) {
      this.resolveUpdatePromise();
      this.resolveUpdatePromise = null;
    }
  }
  contentToStream() {
    return this.currentContent.slice(this.alreadyStreamedContent.length);
  }
};

// src/event-log.ts
import { syncedStore } from "@syncedstore/core";
import { eventLogShape } from "@opensouls/core";
var syncedEventStore = () => syncedStore(eventLogShape);

// src/tool-handler.ts
import { observeDeep } from "@syncedstore/core";
var ToolHandler = class {
  constructor(soul) {
    this.soul = soul;
    this.tools = {};
    this.inProgress = /* @__PURE__ */ new Set();
  }
  registerTool(tool, handler) {
    this.tools[tool] = handler;
  }
  start() {
    this.stopObserving = observeDeep(this.soul.store, () => {
      const pending = Object.entries(this.soul.store.pendingToolCalls ?? {}).filter(
        (entry) => {
          const { request, response } = entry[1] || {};
          if (!request) {
            return false;
          }
          if (response) {
            return false;
          }
          if (this.inProgress.has(request.id)) {
            return false;
          }
          if (!this.tools[request.method]) {
            console.warn("Soul tried to call", request.method, "but this tool is not registered.");
            return false;
          }
          return true;
        }
      );
      for (const [, { request }] of pending) {
        this.inProgress.add(request.id);
        this.executeTool(request).finally(() => {
          this.inProgress.delete(request.id);
        });
      }
    });
  }
  stop() {
    this.stopObserving?.();
  }
  async executeTool(request) {
    try {
      const toolHandler = this.tools[request.method];
      if (!toolHandler) {
        throw {
          code: 404,
          message: "Method not found"
        };
      }
      const result = await toolHandler(request.params);
      this.soul.store.pendingToolCalls[request.id].response = {
        id: request.id,
        result
      };
    } catch (err) {
      this.soul.store.pendingToolCalls[request.id].response = {
        error: {
          code: err.code || -32e3,
          message: err.message || "Internal error",
          data: err.data || null
        },
        id: request.id
      };
    }
  }
};

// src/soul.ts
var Actions = /* @__PURE__ */ ((Actions2) => {
  Actions2["SAYS"] = "says";
  return Actions2;
})(Actions || {});
var Events = /* @__PURE__ */ ((Events2) => {
  Events2["newSoulEvent"] = "newSoulEvent";
  Events2["dispatchExternalPerception"] = "dispatchExternalPerception";
  Events2["compileError"] = "compileError";
  Events2["saveVersion"] = "saveVersion";
  Events2["revertDoc"] = "revertDoc";
  Events2["setEnvironment"] = "setEnvironment";
  Events2["newPerception"] = "newPerception";
  Events2["newInteractionRequest"] = "newInteractionRequest";
  return Events2;
})(Events || {});
function said(entity, content) {
  return {
    action: "said",
    content,
    name: entity
  };
}
var Soul = class extends EventEmitter {
  constructor({
    debug,
    local,
    organization,
    soulId,
    blueprint,
    token,
    version,
    webSocket,
    environment
  }) {
    super();
    this.selfCreatedWebsocket = false;
    if (debug && !token) {
      throw new Error("you must use a token to enable debug chat");
    }
    this.debug = debug;
    this.environment = environment;
    this.organizationSlug = organization;
    this.blueprint = blueprint;
    this.soulId = soulId || uuidv4();
    this.local = Boolean(local);
    this.token = token || "anonymous";
    this.version = version || "prod";
    if (webSocket) {
      this.websocket = webSocket;
      this.connection = this.getProvider();
    }
    this.toolHandler = new ToolHandler(this);
    this.errorHandler = (error) => {
      console.warn("warning: error handler not registered. use onError() to catch errors.");
      throw error.message;
    };
  }
  get events() {
    if (!this.connection) {
      throw new Error("You must call start() before accessing events");
    }
    return this.connection.store.events;
  }
  get store() {
    if (!this.connection) {
      throw new Error("You must call start() before accessing the store");
    }
    this.connection.store.pendingToolCalls ||= {};
    return this.connection.store;
  }
  get connected() {
    return this.connection?.provider.isConnected;
  }
  async connect() {
    if (this.connection) {
      console.warn("connect() called twice on soul");
      return this.soulId;
    }
    if (!this.websocket) {
      this.selfCreatedWebsocket = true;
      if (typeof globalThis.WebSocket === "undefined") {
        const { default: ws } = await import("ws");
        this.websocket = getConnectedWebsocket(this.organizationSlug, this.local, Boolean(this.debug), { WebSocketPolyfill: ws });
      } else {
        this.websocket = getConnectedWebsocket(this.organizationSlug, this.local, Boolean(this.debug));
      }
    }
    if (this.connection) {
      console.warn("connect() called twice on soul");
      return this.soulId;
    }
    this.connection = this.getProvider();
    if (this.debug) {
      console.log("CONNECTED TO SOUL. DEBUG HERE:", this.debugUrl());
    }
    this.toolHandler.start();
    return this.soulId;
  }
  async disconnect() {
    if (!this.connection) {
      throw new Error("You must call start() before stopping");
    }
    this.toolHandler.stop();
    const { provider } = this.connection;
    provider.destroy();
    if (this.selfCreatedWebsocket) {
      provider.configuration.websocketProvider.destroy();
    }
    this.connection = void 0;
    this.removeAllListeners();
  }
  async reset() {
    if (!this.connection) {
      throw new Error("You must call start() before stopping");
    }
    if (!this.debug) {
      throw new Error("You can only reset in debug mode");
    }
    const { provider } = this.connection;
    provider.sendStateless(JSON.stringify({
      event: "revertDoc" /* revertDoc */,
      data: {
        version: "initial"
      }
    }));
  }
  registerTool(tool, handler) {
    return this.toolHandler.registerTool(tool, handler);
  }
  async dispatch(perception) {
    if (!this.connection) {
      throw new Error("You must call start() before saying anything");
    }
    const { provider } = this.connection;
    provider.sendStateless(JSON.stringify({
      event: "dispatchExternalPerception" /* dispatchExternalPerception */,
      data: {
        perception
      }
    }));
  }
  onError(handler) {
    this.errorHandler = handler;
  }
  setEnvironment(environment) {
    if (!this.connection) {
      throw new Error("You must call start() before setting environment");
    }
    this.environment = environment;
    const { provider } = this.connection;
    provider.sendStateless(JSON.stringify({
      event: "setEnvironment" /* setEnvironment */,
      data: {
        environment: this.environment
      }
    }));
  }
  actionEventFromInteractionRequest(interactionRequest) {
    const partialActionEvent = {
      name: interactionRequest.name,
      action: interactionRequest.action,
      _metadata: interactionRequest._metadata,
      _timestamp: interactionRequest._timestamp,
      // @perception is deprecated, use interactionRequest instead
      perception: interactionRequest,
      interactionRequest
    };
    if (!interactionRequest._metadata?.streaming) {
      return {
        content: () => Promise.resolve(interactionRequest.content),
        async *stream() {
          yield interactionRequest.content;
        },
        isStreaming: false,
        ...partialActionEvent
      };
    }
    if (!this.connection) {
      throw new Error("received stateless event before connection was established");
    }
    if (!interactionRequest) {
      throw new Error("received a stateless message for an event that doesn't exist");
    }
    try {
      const streamer = new ContentStreamer();
      const streamCompletePromise = new Promise((resolve) => {
        streamer.onComplete(resolve);
      });
      const disposer = observeDeep2(interactionRequest, () => {
        streamer.updateContent(interactionRequest.content);
        if (interactionRequest._metadata?.streamComplete) {
          disposer();
          streamer.complete();
          return;
        }
      });
      return {
        async content() {
          await streamCompletePromise;
          return interactionRequest.content;
        },
        stream() {
          return streamer.stream();
        },
        isStreaming: true,
        ...partialActionEvent
      };
    } catch (error) {
      console.error("error setting up stream:", error);
      throw error;
    }
  }
  debugUrl() {
    const host = this.local ? "http://localhost:3000" : "https://souls.chat";
    return `${host}/chats/${this.organizationSlug}/${this.blueprint}/${this.soulId}`;
  }
  eventFromPayload(payload) {
    if (!this.connection) {
      throw new Error("You must call start() before handling messages");
    }
    const { data, event: eventType } = JSON.parse(payload);
    return {
      eventType,
      event: data
    };
  }
  getProvider() {
    if (!this.websocket) {
      throw new Error("you must specify a websocket before using getProvider. You can pass one, or start will handle it for you.");
    }
    const store = this.debug ? syncedStore2(debugChatShape) : syncedEventStore();
    const docName = this.debug ? `debug-chat.${this.organizationSlug}.${this.blueprint}.${this.soulId}` : `soul-session.${this.organizationSlug}.${this.blueprint}.${this.soulId}.${this.version}`;
    const provider = new HocuspocusProvider({
      document: getYjsDoc(store),
      name: docName,
      async onAuthenticationFailed({ reason }) {
        console.error("authentication failed", reason);
      },
      onStateless: ({ payload }) => this.handleStatelessMessage(payload),
      token: this.token,
      websocketProvider: this.websocket
    });
    provider.sendStateless(JSON.stringify({
      event: "setEnvironment" /* setEnvironment */,
      data: {
        environment: this.environment
      }
    }));
    return {
      provider,
      store: this.debug ? store.eventLog : store
    };
  }
  async handleStatelessMessage(payload) {
    const { eventType, event: statelessEvent } = this.eventFromPayload(payload);
    if (eventType !== "newSoulEvent" /* newSoulEvent */) {
      return;
    }
    this.emit("newSoulEvent" /* newSoulEvent */, statelessEvent);
    if (statelessEvent._metadata?.type === "error") {
      const uncaughtError = new Error(statelessEvent.content);
      this.errorHandler(uncaughtError);
      return;
    }
    try {
      if (statelessEvent._kind !== SoulEventKinds.InteractionRequest) {
        return;
      }
      const interactionRequest = statelessEvent;
      if (!this.connection) {
        throw new Error("missing connection on handleStatelessMessage");
      }
      const event = this.connection.store.events.find((event2) => event2._id === statelessEvent._id);
      if (!event) {
        throw new Error("received stateless event without a corresponding event in the document");
      }
      this.emit("newPerception" /* newPerception */, interactionRequest);
      this.emit(event.action, this.actionEventFromInteractionRequest(event));
      return;
    } catch (error) {
      console.error("error handling event:", error);
      throw error;
    }
  }
};
export {
  Actions,
  Events,
  Soul,
  getConnectedWebsocket,
  said,
  syncedEventStore,
  websocketUrl
};
//# sourceMappingURL=index.mjs.map
