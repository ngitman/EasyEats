// src/minimal.ts
import { z } from "zod";

// src/cognitiveStep.ts
var createCognitiveStep = (transformationOptionsGenerator) => {
  return async (workingMemory, singleArg, opts = {}) => {
    const transformOpts = transformationOptionsGenerator(singleArg);
    return workingMemory.transform(transformOpts, opts);
  };
};

// src/forkStream.ts
import { ReadableStream } from "web-streams-polyfill";
function forkStream(originalStream, count = 2) {
  const streams = Array.from({ length: count }, () => {
    let controller = { current: null };
    const stream = new ReadableStream({
      start(c) {
        controller.current = c;
      },
      cancel() {
        console.log("Stream was cancelled.");
      }
    });
    return {
      stream,
      controller
    };
  });
  const processStream = async () => {
    try {
      for await (const chunk of originalStream) {
        streams.forEach(({ stream, controller }) => {
          if (controller.current) {
            controller.current.enqueue(chunk);
          }
        });
      }
      streams.forEach(({ stream, controller }) => {
        if (controller.current) {
          controller.current.close();
        }
      });
    } catch (err) {
      console.error("Error processing stream:", err);
      streams.forEach(({ stream, controller }) => {
        if (controller.current) {
          controller.current.error(err);
        }
      });
    }
  };
  processStream();
  return streams.map(({ stream }) => stream);
}

// src/utils.ts
import { codeBlock } from "common-tags";
var indentNicely = codeBlock;
var stripEntityAndVerb = (soulName, _verb, response) => {
  let strippedResponse = response.replace(new RegExp(`${soulName}.*?:`, "i"), "").trim();
  strippedResponse = strippedResponse.replace(/^["']|["']$/g, "").trim();
  return strippedResponse;
};
var stripEntityAndVerbFromStream = async ({ soulName }, stream) => {
  const prefix = new RegExp(`^${soulName}.*?:\\s*["']*`, "i");
  const suffix = /["']$/;
  let isStreaming = !prefix;
  let prefixMatched = !prefix;
  let buffer = "";
  const isStreamingBuffer = [];
  const processedStream = async function* () {
    for await (const chunk of stream) {
      if (isStreaming) {
        if (!suffix) {
          yield chunk;
          continue;
        }
        isStreamingBuffer.push(chunk);
        if (isStreamingBuffer.length > 2) {
          yield isStreamingBuffer.shift();
        }
        continue;
      }
      buffer += chunk;
      if (prefix && prefix.test(buffer)) {
        if (prefixMatched) {
          isStreaming = true;
          buffer = buffer.replace(prefix, "");
          yield buffer;
          buffer = "";
          continue;
        }
        prefixMatched = true;
      }
    }
    buffer = [buffer, ...isStreamingBuffer].join("");
    if (!isStreaming && prefix) {
      buffer = buffer.replace(prefix, "");
    }
    if (buffer.length > 0) {
      if (suffix) {
        buffer = buffer.replace(suffix, "");
        yield buffer;
        return;
      }
      yield buffer;
    }
  }();
  return processedStream;
};

// src/Memory.ts
var ChatMessageRoleEnum = /* @__PURE__ */ ((ChatMessageRoleEnum2) => {
  ChatMessageRoleEnum2["System"] = "system";
  ChatMessageRoleEnum2["User"] = "user";
  ChatMessageRoleEnum2["Assistant"] = "assistant";
  ChatMessageRoleEnum2["Function"] = "function";
  return ChatMessageRoleEnum2;
})(ChatMessageRoleEnum || {});
export {
  ChatMessageRoleEnum,
  createCognitiveStep,
  forkStream,
  indentNicely,
  stripEntityAndVerb,
  stripEntityAndVerbFromStream,
  z
};
//# sourceMappingURL=minimal.mjs.map
