{
  "version": 3,
  "sources": ["../src/index.ts", "../src/cognitiveStep.ts", "../src/processors/OpenAIProcessor.ts", "../src/processors/registry.ts", "../src/Memory.ts", "../src/processors/Processor.ts", "../src/processors/messageRoleFixer.ts", "../src/utils.ts", "../src/forkStream.ts", "../src/processors/AnthropicProcessor.ts", "../src/WorkingMemory.ts", "../src/sharedTypes/eventLog.ts"],
  "sourcesContent": ["export { z } from 'zod';\n\nexport * from './cognitiveStep.js'\nexport * from './processors/index.js'\nexport * from './forkStream.js'\nexport * from './utils.js'\nexport * from './WorkingMemory.js'\nexport * from './Memory.js'\n\nexport * from \"./sharedTypes/index.js\"\n", "import type { ZodSchema } from \"zod\"\nimport type { ProcessorSpecification, WorkingMemory } from \"./WorkingMemory.js\"\nimport type { RequestOptions } from \"./processors/Processor.js\"\nimport { InputMemory } from \"./Memory.js\"\n\nexport type StreamProcessor = (workingMemory: WorkingMemory, stream: AsyncIterable<string>) => (AsyncIterable<string> | Promise<AsyncIterable<string>>)\n\nexport type PostProcessReturn<SchemaType> = [InputMemory, SchemaType]\n\nexport interface MemoryTransformationOptions<SchemaType = string, PostProcessType = SchemaType> {\n  command: string | ((workingMemory: WorkingMemory) => InputMemory)\n\n  processor?: string\n  schema?: ZodSchema<SchemaType>\n  postProcess?: (originalMemory: WorkingMemory, response: SchemaType) => (Promise<PostProcessReturn<PostProcessType>> | PostProcessReturn<PostProcessType>)\n  streamProcessor?: StreamProcessor\n  skipAutoSchemaAddition?: boolean\n}\n\nexport type TransformOptions =\n  RequestOptions &\n  {\n    stream?: boolean\n    processor?: ProcessorSpecification\n  }\n\nexport type TransformReturnStreaming<PostProcessType> = [WorkingMemory, AsyncIterable<string>, Promise<PostProcessType>]\nexport type TransformReturnNonStreaming<PostProcessType> = [WorkingMemory, PostProcessType]\nexport type TransformReturn<PostProcessType> = TransformReturnStreaming<PostProcessType> | TransformReturnNonStreaming<PostProcessType>\n\nexport type CognitiveStep<UserArgType, PostProcessReturnType> = {\n  (memory: WorkingMemory, userArgs: UserArgType, transformOpts: TransformOptions & { stream: true }): Promise<TransformReturnStreaming<PostProcessReturnType>>\n  (memory: WorkingMemory, userArgs: UserArgType, transformOpts?: Omit<TransformOptions, \"stream\">): Promise<TransformReturnNonStreaming<PostProcessReturnType>>\n  (memory: WorkingMemory, userArgs: UserArgType, transformOpts: Omit<TransformOptions, \"stream\"> & { stream: false }): Promise<TransformReturnNonStreaming<PostProcessReturnType>>\n}\n\n/**\n * Creates a new CognitiveStep function configured with the specified transformation logic.\n * This function is pivotal in the cognitive processing pipeline, allowing for dynamic\n * transformation of working memory based on user-defined logic and conditions.\n *\n * @param transformationOptionsGenerator A callback function that takes a single argument and returns a `MemoryTransformationOptions` object.\n *           This callback defines the transformation logic applied in the cognitive step.\n *           The single argument can be any user-defined data structure or value that the callback\n *           uses to determine the transformation logic.\n * @returns A `CognitiveStep` function that takes a `WorkingMemory` instance, user arguments, and\n *          request options. It applies the transformation logic defined by the `transformationOptionsGenerator` callback\n *          to the working memory and returns the transformed memory along with any post-processing results.\n *          The function supports both streaming and non-streaming modes based on the provided request options.\n *\n * Trivial exmaple:\n * Defines a CognitiveStep that answers a user's question in a single word.\n * The transformation logic includes a command as a string, a schema to validate the response using Zod, and a post-processing function that converts the response to uppercase.\n * This cognitive step is then used to transform the working memory based on user arguments and transformation options, supporting both streaming and non-streaming modes.\n * ```\n * const myCognitiveStep = createCognitiveStep((singleArg) => ({\n *   command: \"Answer the user's question in a single word.\",\n *   schema: z.object({ answer: z.string() }),\n *   postProcess: async (originalMemory, response) => [originalMemory, response.toUpperCase()],\n * }));\n *\n * // To use the cognitive step:\n * const [newMemory, result] = await myCognitiveStep(workingMemory, userArgs);\n * // or\n * const [newMemory, stream, resultPromise] = await myCognitiveStep(workingMemory, userArgs, { stream: true })\n * ```\n */\nexport const createCognitiveStep =\n  <UserArgType = undefined, SchemaType = string, PostProcessType = SchemaType>(\n    transformationOptionsGenerator: (singleArg: UserArgType) => MemoryTransformationOptions<SchemaType, PostProcessType>\n  ): CognitiveStep<UserArgType, PostProcessType> => {\n\n    return (async (workingMemory: WorkingMemory, singleArg: UserArgType, opts: TransformOptions = {}) => {\n      const transformOpts = transformationOptionsGenerator(singleArg)\n      return workingMemory.transform(transformOpts, opts)\n    }) as CognitiveStep<UserArgType, PostProcessType>\n  }\n", "import OpenAI from \"openai\";\nimport { encodeChatGenerator, encodeGenerator } from \"gpt-tokenizer/model/gpt-4\"\nimport { RequestOptions } from \"openai/core\";\nimport { trace, context } from \"@opentelemetry/api\";\nimport { backOff } from \"exponential-backoff\";\nimport { ChatMessage } from \"gpt-tokenizer/GptEncoding\";\nimport { ZodError, fromZodError } from 'zod-validation-error';\n\nimport { registerProcessor } from \"./registry.js\";\nimport { ChatMessageRoleEnum, ContentText, Memory } from \"../Memory.js\";\nimport { ChatCompletionMessageParam } from \"openai/resources/chat/completions\";\n\nimport {\n  extractJSON,\n  Processor,\n  prepareMemoryForJSON,\n  UsageNumbers,\n  ProcessOpts,\n  ProcessResponse\n} from \"./Processor.js\";\nimport { fixMessageRoles } from \"./messageRoleFixer.js\";\nimport { indentNicely } from \"../utils.js\";\nimport { forkStream } from \"../forkStream.js\";\n\nconst tracer = trace.getTracer(\n  'open-souls-OpenAIProcessor',\n  '0.0.1',\n);\n\nconst tokenLength = (messagesOrContent: ChatMessage[] | string): number => {\n  // first count out all the images in the memories\n  let tokenCount = 0\n\n  if (typeof messagesOrContent === \"string\") {\n    for (const tokens of encodeGenerator(messagesOrContent)) {\n      tokenCount += tokens.length\n    }\n\n    return tokenCount\n  }\n\n  const messagesWithoutImages = messagesOrContent.map((m) => {\n    if (!Array.isArray(m.content)) {\n      return m\n    }\n    const text = m.content.find((c) => c.type === \"text\") as ContentText\n    const images = m.content.filter((c) => c.type === \"image_url\")\n    // TODO: for now let's treat everything as a 1024x1024 image\n    tokenCount += images.length * 765\n    return {\n      ...m,\n      content: text?.text || \"\"\n    }\n  })\n\n  for (const tokens of encodeChatGenerator(messagesWithoutImages as any[])) {\n    tokenCount += tokens.length\n  }\n\n  return tokenCount\n}\n\nexport type OpenAIClientConfig = ConstructorParameters<typeof OpenAI>[0];\n\nconst memoryToChatMessage = (memory: Memory): ChatCompletionMessageParam => {\n  return {\n    role: memory.role,\n    content: memory.content,\n    ...(memory.name && { name: memory.name })\n  } as ChatCompletionMessageParam\n}\n\nexport interface OpenAIProcessorOpts {\n  clientOptions?: OpenAIClientConfig\n  defaultCompletionParams?: Partial<OpenAI.Chat.Completions.ChatCompletionCreateParams>\n  defaultRequestOptions?: Partial<RequestOptions>\n  singleSystemMessage?: boolean,\n  forcedRoleAlternation?: boolean,\n  disableResponseFormat?: boolean,\n}\n\nasync function* chunkStreamToTextStream(chunkStream: AsyncIterable<OpenAI.Chat.Completions.ChatCompletionChunk>) {\n  try {\n    for await (const chunk of chunkStream) {\n      yield chunk.choices[0].delta.content || \"\"\n    }\n  } catch (err) {\n    console.error(\"chunkStreamToTextStream error\", err)\n    throw err\n  }\n}\n\nconst DEFAULT_MODEL = \"gpt-3.5-turbo-0125\"\n\nexport class OpenAIProcessor implements Processor {\n  static label = \"openai\"\n  private client: OpenAI\n\n  private singleSystemMessage: boolean\n  private forcedRoleAlternation: boolean\n  private disableResponseFormat: boolean // default this one to true\n\n  private defaultRequestOptions: Partial<RequestOptions>\n  private defaultCompletionParams: Partial<OpenAI.Chat.Completions.ChatCompletionCreateParams>\n\n  constructor({ clientOptions, singleSystemMessage, forcedRoleAlternation, defaultRequestOptions, defaultCompletionParams, disableResponseFormat }: OpenAIProcessorOpts) {\n    this.client = new OpenAI(clientOptions)\n    this.singleSystemMessage = singleSystemMessage || false\n    this.forcedRoleAlternation = forcedRoleAlternation || false\n    this.defaultRequestOptions = defaultRequestOptions || {}\n    this.disableResponseFormat = disableResponseFormat || false\n    this.defaultCompletionParams = defaultCompletionParams || {}\n  }\n\n  async process<SchemaType = string>(opts: ProcessOpts<SchemaType>): Promise<ProcessResponse<SchemaType>> {\n    return tracer.startActiveSpan(\"OpenAIProcessor.process\", async (span) => {\n      try {\n        context.active()\n\n        let memory = opts.memory\n        if (opts.schema) {\n          memory = prepareMemoryForJSON(memory)\n        }\n\n        span.setAttributes({\n          processOptions: JSON.stringify(opts),\n          memory: JSON.stringify(memory),\n        })\n\n        return backOff(\n          async () => {\n            const resp = await this.execute({\n              ...opts,\n              memory,\n            })\n\n            // TODO: how do we both return a stream *and* also parse the json and retry?\n            if (opts.schema) {\n              const completion = await resp.rawCompletion\n              const extracted = extractJSON(completion)\n              span.addEvent(\"extracted\")\n              span.setAttribute(\"extracted\", extracted || \"none\")\n              if (!extracted) {\n                console.error(\"no json found in completion\", completion)\n                throw new Error('no json found in completion')\n              }\n              try {\n                const parsed = opts.schema.parse(JSON.parse(extracted))\n                span.addEvent(\"parsed\")\n                span.end()\n                return {\n                  ...resp,\n                  parsed: Promise.resolve(parsed),\n                }\n              } catch (err: any) {\n                span.recordException(err)\n                const zodError = fromZodError(err as ZodError)\n                console.log(\"zod error\", zodError.toString())\n                memory = memory.concat([\n                  {\n                    role: ChatMessageRoleEnum.Assistant,\n                    content: extracted,\n                  },\n                  {\n                    role: ChatMessageRoleEnum.User,\n                    content: indentNicely`\n                      ## JSON Errors\n                      ${zodError.toString()}.\n                      \n                      Please fix the error(s) and try again, conforming exactly to the provided JSON schema.\n                    `\n                  }\n                ])\n                throw err\n              }\n\n            }\n\n            return {\n              ...resp,\n              parsed: (resp.rawCompletion as Promise<SchemaType>)\n            }\n          },\n          {\n            numOfAttempts: 5,\n            retry: (err) => {\n              if (err.message.includes(\"aborted\")) {\n                return false\n              }\n              span.addEvent(\"retry\")\n              console.error(\"retrying due to error\", err)\n\n              return true\n            },\n          })\n      } catch (err: any) {\n        console.error(\"error in process\", err)\n        span.recordException(err)\n        span.end()\n        throw err\n      }\n    })\n\n  }\n\n  private async execute<SchemaType = any>({\n    maxTokens,\n    memory,\n    model: developerSpecifiedModel,\n    schema,\n    signal,\n    timeout,\n    temperature,\n  }: ProcessOpts<SchemaType>): Promise<Omit<ProcessResponse<SchemaType>, \"parsed\">> {\n    return tracer.startActiveSpan(\"OpenAIProcessor.execute\", async (span) => {\n      try {\n        const model = developerSpecifiedModel || this.defaultCompletionParams.model || DEFAULT_MODEL\n        const messages = this.possiblyFixMessageRoles(memory.memories.map(memoryToChatMessage))\n        const params = {\n          ...this.defaultCompletionParams,\n          ...(maxTokens && { max_tokens: maxTokens }),\n          model,\n          messages,\n          temperature: temperature || 0.8,\n          stream: true,\n        }\n\n        span.setAttributes({\n          outgoingParams: JSON.stringify(params),\n        })\n\n        const stream = await this.client.chat.completions.create(\n          {\n            ...params,\n            stream: true,\n            ...(!this.disableResponseFormat && { response_format: { type: schema ? \"json_object\" : \"text\" } })\n          },\n          {\n            ...this.defaultRequestOptions,\n            signal,\n            timeout: timeout || 10_000,\n          }\n        )\n\n        const [textStream1, textStream2] = forkStream(chunkStreamToTextStream(stream), 2)\n\n        // const textStream = new ReusableStream(chunkStreamToTextStream(stream))\n\n        const fullContentPromise = new Promise<string>(async (resolve, reject) => {\n          try {\n            let fullText = \"\"\n            for await (const message of textStream1) {\n              span.addEvent(\"chunk\", { length: message.length })\n              fullText += message\n            }\n            // console.log(\"resolving\")\n            span.setAttribute(\"response\", fullText)\n            resolve(fullText)\n          } catch (err) {\n            reject(err)\n          }\n        })\n\n        const usagePromise = new Promise<UsageNumbers>(async (resolve, reject) => {\n          try {\n            const fullContent = await fullContentPromise\n\n            const [inputTokenCount, outputTokenCount] = await Promise.all([\n              tokenLength(messages as ChatMessage[]),\n              tokenLength(fullContent),\n            ]);\n\n            span.setAttribute(\"model\", model)\n            span.setAttribute(\"usage-input\", inputTokenCount)\n            span.setAttribute(\"usage-output\", outputTokenCount)\n            resolve({\n              model,\n              input: inputTokenCount,\n              output: outputTokenCount\n            })\n          } catch (err) {\n            reject(err)\n          } finally {\n            span.end()\n          }\n        })\n\n        return {\n          rawCompletion: fullContentPromise,\n          stream: textStream2,\n          usage: usagePromise,\n        }\n      } catch (err: any) {\n        span.recordException(err)\n        span.end()\n        throw err\n      }\n    })\n  }\n\n  private possiblyFixMessageRoles(messages: (ChatMessage | ChatCompletionMessageParam)[]): ChatCompletionMessageParam[] {\n    return fixMessageRoles({ singleSystemMessage: this.singleSystemMessage, forcedRoleAlternation: this.forcedRoleAlternation }, messages)\n  }\n}\n\nregisterProcessor(OpenAIProcessor.label, (opts: Partial<OpenAIProcessorOpts> = {}) => new OpenAIProcessor(opts))\n", "import { Processor, ProcessorCreationOpts, ProcessorFactory } from './Processor.js'\n\nconst processorRegistry: Record<string, ProcessorFactory > = {}\n\nexport function registerProcessor(name: string, processor: ProcessorFactory) {\n  if (processorRegistry[name]) {\n    throw new Error(`Processor with name ${name} already exists`)\n  }\n  processorRegistry[name] = processor\n}\n\nexport function getProcessor(name: string, opts?: ProcessorCreationOpts): Processor {\n  if (!processorRegistry[name]) {\n    throw new Error(`Processor with name ${name} does not exist`)\n  }\n  return processorRegistry[name](opts)\n}\n", "\nexport enum ChatMessageRoleEnum {\n  System = \"system\",\n  User = \"user\",\n  Assistant = \"assistant\",\n  Function = \"function\",\n}\n\nexport interface ImageURL {\n  /**\n   * Either a URL of the image or the base64 encoded image data.\n   */\n  url: string;\n\n  /**\n   * Specifies the detail level of the image. Learn more in the\n   * [Vision guide](https://platform.openai.com/docs/guides/vision/low-or-high-fidelity-image-understanding).\n   */\n  detail?: 'auto' | 'low' | 'high';\n}\n\nexport type ContentText = { type: \"text\", text: string }\nexport type ContentImage = { type: \"image_url\", image_url: ImageURL }\n\nexport type ChatMessageContent = string | (ContentText | ContentImage)[]\n\nexport interface Memory<MetaDataType = Record<string, unknown>> {\n  role: ChatMessageRoleEnum;\n  content: ChatMessageContent;\n  name?: string;\n  metadata?: MetaDataType;\n\n  _id: string;\n  _timestamp: number;\n}\n\nexport type InputMemory = Omit<Memory, \"_id\" | \"_timestamp\"> & { _id?: string, _timestamp?: number }\n", "import { ZodSchema } from \"zod\"\nimport { WorkingMemory } from \"../WorkingMemory.js\"\nimport { ChatMessageContent, ChatMessageRoleEnum, ContentText } from \"../Memory.js\"\n\nexport interface UsageNumbers {\n  model: string,\n  input: number,\n  output: number\n}\n\nexport interface ProcessResponse<SchemaType = string> {\n  rawCompletion: Promise<string>\n  parsed: Promise<SchemaType>\n  stream: AsyncIterable<string>\n  usage: Promise<UsageNumbers>\n}\n\nexport type Headers = Record<string, string | null | undefined>;\n\nexport interface RequestOptions {\n  model?: string\n  temperature?: number\n  maxTokens?: number\n\n  signal?: AbortSignal\n  tags?: Record<string, string>\n  timeout?: number;\n  headers?: Headers;\n  additionalRequestOptions?: Record<string, any>\n}\n\nexport interface ProcessOpts<SchemaType = string> extends RequestOptions {\n  memory: WorkingMemory,\n  schema?: ZodSchema<SchemaType>\n}\n\nexport interface Processor {\n  process<SchemaType = string>(opts: ProcessOpts<SchemaType>): Promise<ProcessResponse<SchemaType>>\n}\n\nexport interface ProcessorCreationOpts {\n  //todo\n}\nexport type ProcessorFactory = (opts?: ProcessorCreationOpts) => Processor\n\n\nconst textFromContent = (content: ChatMessageContent) => {\n  if (typeof content === \"string\") {\n    return content\n  }\n  const textContent = content.find((c) => c.type === \"text\") as ContentText | undefined\n  if (!textContent) {\n    return \"\"\n  }\n  return textContent.text\n}\n\nconst JSON_MESSAGE = \"You only speak JSON. Respond only with JSON properly conforming to the provided schema (but not returning the schema itself), with no other content.\"\n\nexport const prepareMemoryForJSON = (workingMemory: WorkingMemory, jsonMessage = JSON_MESSAGE) => {\n  // get the system memory\n  const systemMem = workingMemory.find((memory) => memory.role === ChatMessageRoleEnum.System)\n  if (systemMem && textFromContent(systemMem.content).includes(\"JSON\")) {\n    return workingMemory\n  }\n\n  if (systemMem) {\n    return workingMemory.map((memory) => {\n      if (memory._id === systemMem._id) {\n        return {\n          ...memory,\n          content: systemMem.content + \" \\n\\n \" + jsonMessage,\n        }\n      }\n      return memory \n    })\n  }\n\n  // no system message, prepend\n  return workingMemory.prepend([{\n    role: ChatMessageRoleEnum.System,\n    content: jsonMessage\n  }])\n}\n\n\nexport function extractJSON(str?: string | null) {\n  if (!str) return null;\n\n  const jsonStart = str.indexOf('{');\n  if (jsonStart === -1) return null;\n  \n  for (let i = jsonStart; i < str.length; i++) {\n      if (str[i] === '}') {\n          const potentialJson = str.slice(jsonStart, i + 1);\n          try {\n              JSON.parse(potentialJson);\n              return potentialJson;\n          } catch (e) {\n              // Not valid JSON\n          }\n      }\n  }\n\n  return null;\n}\n", "import { ChatMessage } from \"gpt-tokenizer/GptEncoding\"\nimport { ChatCompletionCreateParams, ChatCompletionMessageParam } from \"openai/resources/index.mjs\"\nimport { ChatMessageContent, ChatMessageRoleEnum, ContentImage, ContentText } from \"../Memory.js\"\n\nexport interface FixMethods {\n  singleSystemMessage?: boolean\n  forcedRoleAlternation?: boolean\n}\n\nexport const fixMessageRoles = (fixMethods: FixMethods, messages: (ChatMessage | ChatCompletionMessageParam)[]): ChatCompletionMessageParam[] => {\n  if (!fixMethods.singleSystemMessage && !fixMethods.forcedRoleAlternation) {\n    return messages as ChatCompletionMessageParam[]\n  }\n\n  let newMessages = messages\n\n  if (fixMethods.singleSystemMessage) {\n    newMessages = messages.map((originalMessage, i) => {\n      const message = { ...originalMessage }\n      if (i === 0) {\n        return message\n      }\n      if (message.role === ChatMessageRoleEnum.System) {\n        message.role = ChatMessageRoleEnum.User\n        return message\n      }\n      return message\n    }) as ChatCompletionMessageParam[]\n  }\n\n  if (fixMethods.forcedRoleAlternation) {\n    // now we make sure that all the messages alternate User/Assistant/User/Assistant\n    let lastRole: ChatCompletionCreateParams[\"messages\"][0][\"role\"] | undefined\n    const { messages } = newMessages.reduce((acc, message) => {\n      // If it's the first message or the role is different from the last, push it to the accumulator\n      if (lastRole !== message.role) {\n        acc.messages.push(message);\n        lastRole = message.role;\n        acc.grouped = [message.content as ChatMessageContent]\n      } else {\n        // If the role is the same, combine the content with the last message in the accumulator\n        const lastMessage = acc.messages[acc.messages.length - 1];\n        acc.grouped.push(message.content as ChatMessageContent)\n\n        lastMessage.content = mergeContent(acc.grouped)\n      }\n\n      return acc;\n    }, { messages: [], grouped: [] } as { grouped: ChatMessageContent[], messages: (ChatMessage | ChatCompletionMessageParam)[] })\n\n    newMessages = messages\n    if (newMessages[0]?.role === ChatMessageRoleEnum.Assistant) {\n      newMessages.unshift({\n        content: \"...\",\n        role: ChatMessageRoleEnum.User\n      })\n    }\n  }\n\n  return newMessages as ChatCompletionMessageParam[]\n}\n\nconst extractTextFromContent = (content: ChatMessageContent): string => {\n  if (Array.isArray(content)) {\n    return content.map((c) => {\n      if (c.type === \"text\") {\n        return c.text\n      }\n      return \"\"\n    }).join(\"\\n\")\n  }\n\n  return content || \"\"\n}\n\nconst extractImageFromContent = (content: ChatMessageContent): ContentImage[] => {\n  if (Array.isArray(content)) {\n    return content.filter((c) => c.type === \"image_url\") as ContentImage[]\n  }\n\n  return []\n}\n\nconst mergeContent = (messages: ChatMessageContent[]): ChatMessageContent => {\n  const newContent: ChatMessageContent = [\n    {\n      type: \"text\",\n      text: \"\"\n    }\n  ]\n\n  for (const message of messages) {\n    const txt = extractTextFromContent(message);\n    const images = extractImageFromContent(message);\n    newContent.push(...images);\n    (newContent[0] as ContentText).text += txt + \"\\n\\n\"\n  }\n\n  return newContent\n}", "import type { WorkingMemory } from \"./WorkingMemory.js\";\nimport { codeBlock } from \"common-tags\"\n\nexport const indentNicely = codeBlock\n\nexport const stripEntityAndVerb = (soulName: string, _verb: string, response: string) => {\n  // sometimes the LLM will respond with something like \"Bogus said with a sinister smile: \"I'm going to eat you!\" (adding more words)\n  // so we just strip any of those\n  let strippedResponse = response.replace(new RegExp(`${soulName}.*?:`, \"i\"), \"\").trim();\n  // get rid of the quotes\n  strippedResponse = strippedResponse.replace(/^[\"']|[\"']$/g, '').trim();\n  return strippedResponse\n}\n\nexport const stripEntityAndVerbFromStream = async ({ soulName }: WorkingMemory, stream: AsyncIterable<string>): Promise<AsyncIterable<string>> => {\n  const prefix = new RegExp(`^${soulName}.*?:\\\\s*[\"']*`, \"i\")\n  const suffix = /[\"']$/\n\n  let isStreaming = !prefix\n  let prefixMatched = !prefix\n  let buffer = \"\"\n  const isStreamingBuffer: string[] = []\n\n  const processedStream = (async function* () {\n    for await (const chunk of stream) {\n      // if we are already streaming, then we need to look out for a suffix\n      // we keep the last 2 chunks in the buffer to check after the stream is finished\n      // othwerwise we keep streaming\n      if (isStreaming) {\n        if (!suffix) {\n          yield chunk\n          continue;\n        }\n        isStreamingBuffer.push(chunk)\n        if (isStreamingBuffer.length > 2) {\n          yield isStreamingBuffer.shift() as string\n        }\n        continue;\n      }\n\n      // if we're not streaming, then keep looking for the prefix, and allow one *more* chunk\n      // after detecting a hit on the prefix to come in, in case the prefix has some optional ending\n      // characters.\n      buffer += chunk;\n      if (prefix && prefix.test(buffer)) {\n        if (prefixMatched) {\n          isStreaming = true;\n\n          buffer = buffer.replace(prefix, '');\n          yield buffer; // yield everything after the prefix\n          buffer = ''; // clear the buffer\n          continue\n        }\n        prefixMatched = true\n      }\n    }\n    buffer = [buffer, ...isStreamingBuffer].join('')\n    // if we ended before switching on streaming, then we haven't stripped the prefix yet.\n    if (!isStreaming && prefix) {\n      buffer = buffer.replace(prefix, '');\n    }\n    if (buffer.length > 0) {\n      // if there was some buffer left over, then we need to check if there was a suffix\n      // and remove that from the last part of the stream.\n      if (suffix) {\n        buffer = buffer.replace(suffix, '');\n        yield buffer; // yield everything before the suffix\n        return\n      }\n      // if there was no suffix, then just yield what's left.\n      yield buffer; // yield the last part of the buffer if anything is left\n    }\n  })();\n  return processedStream;\n}\n", "import { ReadableStream } from 'web-streams-polyfill';\n\nexport function forkStream<T>(originalStream: AsyncIterable<T>, count = 2): ReadableStream<T>[] {\n  const streams = Array.from({ length: count }, () => {\n    let controller: { current: ReadableStreamDefaultController<T> | null } = { current: null };\n\n    const stream = new ReadableStream<T>({\n      start(c) {\n        controller.current = c;\n      },\n      cancel() {\n        console.log('Stream was cancelled.');\n      }\n    });\n\n    return {\n      stream,\n      controller\n    };\n  });\n\n  const processStream = async () => {\n    try {\n      for await (const chunk of originalStream) {\n        streams.forEach(({ stream, controller }) => {\n          if (controller.current) {\n            controller.current.enqueue(chunk);\n          }\n        });\n      }\n      streams.forEach(({ stream, controller }) => {\n        if (controller.current) {\n          controller.current.close();\n        }\n      });\n    } catch (err) {\n      console.error('Error processing stream:', err);\n      streams.forEach(({ stream, controller }) => {\n        if (controller.current) {\n          controller.current.error(err);\n        }\n      });\n    }\n  };\n\n  processStream();\n\n  return streams.map(({ stream }) => stream);\n}", "import Anthropic from '@anthropic-ai/sdk';\nimport { trace, context } from \"@opentelemetry/api\";\nimport { registerProcessor } from \"./registry.js\";\nimport { ChatMessageRoleEnum, Memory } from \"../Memory.js\";\nimport { ChatCompletionMessageParam } from \"openai/resources/chat/completions\";\n\nimport {\n  extractJSON,\n  Processor,\n  prepareMemoryForJSON,\n  UsageNumbers,\n  ProcessOpts,\n  ProcessResponse\n} from \"./Processor.js\";\nimport { backOff } from \"exponential-backoff\";\nimport { ChatMessage } from \"gpt-tokenizer/GptEncoding\";\nimport { fixMessageRoles } from './messageRoleFixer.js';\nimport { forkStream } from '../forkStream.js';\n\nconst tracer = trace.getTracer(\n  'open-souls-OpenAIProcessor',\n  '0.0.1',\n);\n\ninterface AnthropicMessage {\n  content: string\n  role: ChatMessageRoleEnum.Assistant | ChatMessageRoleEnum.User\n}\n\nexport interface ICompatibleAnthropicClient {\n  new (options: AnthropicClientConfig): CompatibleAnthropicClient;\n}\n\nexport type CompatibleAnthropicClient = {\n  messages: {\n    stream: (body: AnthropicCompletionParams, options?: AnthropicRequestOptions) => AsyncIterable<Anthropic.MessageStreamEvent>\n  }\n}\n\nexport type AnthropicClientConfig = ConstructorParameters<typeof Anthropic>[0]\n\nexport type AnthropicCompletionParams = Anthropic[\"messages\"][\"stream\"][\"arguments\"][0]\nexport type AnthropicRequestOptions = Anthropic[\"messages\"][\"stream\"][\"arguments\"][1]\n\nexport type AnthropicDefaultCompletionParams = AnthropicCompletionParams & {\n  model: AnthropicCompletionParams[\"model\"] | string;\n};\n\nconst memoryToChatMessage = (memory: Memory): ChatCompletionMessageParam => {\n  return {\n    role: memory.role,\n    content: memory.content,\n    ...(memory.name && { name: memory.name })\n  } as ChatCompletionMessageParam\n}\n\nexport interface AnthropicProcessorOpts {\n  clientOptions?: AnthropicClientConfig\n  defaultCompletionParams?: Partial<AnthropicDefaultCompletionParams>\n  defaultRequestOptions?: Partial<AnthropicRequestOptions>\n  customClient?: ICompatibleAnthropicClient\n}\n\nconst openAiToAnthropicMessages = (openAiMessages: ChatCompletionMessageParam[]): { system?: string, messages: AnthropicMessage[] } => {\n  let systemMessage: string | undefined\n\n  const messages = openAiMessages.map((m) => {\n    if (m.role === ChatMessageRoleEnum.System) {\n      if (openAiMessages.length > 1) {\n        systemMessage ||= \"\"\n        systemMessage += m.content + \"\\n\"\n        return undefined\n      }\n\n      return {\n        content: m.content,\n        role: ChatMessageRoleEnum.User,\n      } as AnthropicMessage\n    }\n    return {\n      content: m.content,\n      role: m.role\n    } as AnthropicMessage\n  }).filter(Boolean) as AnthropicMessage[]\n\n  // claude requires the first message to be user.\n  if (messages[0]?.role === ChatMessageRoleEnum.Assistant) {\n    messages.unshift({\n      content: \"...\",\n      role: ChatMessageRoleEnum.User\n    })\n  }\n\n  return { system: systemMessage, messages: messages }\n}\n\nasync function* chunkStreamToTextStream(chunkStream: AsyncIterable<Anthropic.MessageStreamEvent>) {\n  try {\n    for await (const evt of chunkStream) {\n      if (evt.type !== \"content_block_delta\") {\n        continue\n      }\n  \n      yield evt.delta.text;\n    }\n  } catch (err: any) {\n    if (err.message?.toLowerCase().includes(\"abort\")) {\n      return;\n    }\n    throw err\n  }\n}\n\nasync function chunkStreamToUsage(chunkStream: AsyncIterable<Anthropic.MessageStreamEvent>) {\n  const usage = { input: 0, output: 0 }\n\n  for await (const evt of chunkStream) {\n    if (evt.type === \"message_start\") {\n      usage.input = evt.message.usage.input_tokens\n    }\n\n    if (evt.type === \"message_delta\" && evt.usage) {\n      usage.output = evt.usage.output_tokens\n    }\n  }\n  \n  return usage\n}\n\nconst DEFAULT_MODEL = \"claude-3-opus-20240229\"\n\nexport class AnthropicProcessor implements Processor {\n  static label = \"anthropic\"\n  private client: CompatibleAnthropicClient\n\n  private defaultRequestOptions: Partial<AnthropicRequestOptions>\n  private defaultCompletionParams: Partial<AnthropicDefaultCompletionParams>\n\n  constructor({ clientOptions, defaultRequestOptions, defaultCompletionParams, customClient }: AnthropicProcessorOpts) {\n    this.client = new (customClient ?? Anthropic)(clientOptions)\n    this.defaultRequestOptions = defaultRequestOptions || {}\n    this.defaultCompletionParams = defaultCompletionParams || {}\n  }\n\n  async process<SchemaType = string>(opts: ProcessOpts<SchemaType>): Promise<ProcessResponse<SchemaType>> {\n    return tracer.startActiveSpan(\"OpenAIProcessor.process\", async (span) => {\n      context.active()\n\n      let memory = opts.memory\n      if (opts.schema) {\n        memory = prepareMemoryForJSON(memory)\n      }\n\n      span.setAttributes({\n        processOptions: JSON.stringify(opts),\n        memory: JSON.stringify(memory),\n      })\n\n      return backOff(\n        async () => {\n          const resp = await this.execute({\n            ...opts,\n            memory,\n          })\n\n          // TODO: how do we both return a stream *and* also parse the json and retry?\n          if (opts.schema) {\n            const completion = await resp.rawCompletion\n            const extracted = extractJSON(completion)\n            span.addEvent(\"extracted\")\n            span.setAttribute(\"extracted\", extracted || \"none\")\n            if (!extracted) {\n              throw new Error('no json found in completion')\n            }\n            const parsed = opts.schema.parse(JSON.parse(extracted))\n            span.addEvent(\"parsed\")\n            span.end()\n            return {\n              ...resp,\n              parsed: Promise.resolve(parsed),\n            }\n          }\n\n          return {\n            ...resp,\n            parsed: (resp.rawCompletion as Promise<SchemaType>)\n          }\n        },\n        {\n          numOfAttempts: 5,\n          retry: (err) => {\n            if (err.message.includes(\"aborted\")) {\n              return false\n            }\n            span.addEvent(\"retry\")\n            console.error(\"retrying due to error\", err)\n\n            return true\n          },\n        })\n    })\n\n  }\n\n  private async execute<SchemaType = any>({\n    maxTokens,\n    memory,\n    model: developerSpecifiedModel,\n    signal,\n    timeout,\n    temperature,\n  }: ProcessOpts<SchemaType>): Promise<Omit<ProcessResponse<SchemaType>, \"parsed\">> {\n    return tracer.startActiveSpan(\"AnthropicProcessor.execute\", async (span) => {\n      try {\n        const model = developerSpecifiedModel || this.defaultCompletionParams.model || DEFAULT_MODEL\n\n        const { system, messages } = openAiToAnthropicMessages(this.possiblyFixMessageRoles(memory.memories.map(memoryToChatMessage)))\n\n        const params = {\n          system,\n          max_tokens: maxTokens || this.defaultCompletionParams.max_tokens || 512,\n          model,\n          messages,\n          temperature: temperature || 0.8,\n        }\n\n        span.setAttributes({\n          outgoingParams: JSON.stringify(params),\n        })\n\n        // TODO, do we want to do anything with schema here to make claude more aware of JSON?\n        const stream = this.client.messages.stream(\n          {\n            ...this.defaultCompletionParams,\n            ...params,\n          },\n          {\n            ...this.defaultRequestOptions,\n            signal,\n            timeout: timeout || 10_000,\n          }\n        )\n\n        const [baseStream1, baseStream2] = forkStream(stream, 2)\n        const [textStream1, textStream2] = forkStream(chunkStreamToTextStream(baseStream1), 2)\n\n        // const baseStream = new ReusableStream(stream)\n\n        // const textStream = new ReusableStream(chunkStreamToTextStream(baseStream1))\n\n        const fullContentPromise = new Promise<string>(async (resolve, reject) => {\n          try {\n            let fullText = \"\"\n            for await (const message of textStream1) {\n              span.addEvent(\"chunk\", { length: message.length })\n              fullText += message\n            }\n            // console.log(\"resolving\")\n            span.setAttribute(\"response\", fullText)\n            resolve(fullText)\n          } catch (err) {\n            reject(err)\n          }\n        })\n\n        const usagePromise = new Promise<UsageNumbers>(async (resolve, reject) => {\n          try {\n            const { input: inputTokenCount, output: outputTokenCount } = await chunkStreamToUsage(baseStream2)\n            \n            span.setAttribute(\"model\", model)\n            span.setAttribute(\"usage-input\", inputTokenCount)\n            span.setAttribute(\"usage-output\", outputTokenCount)\n            resolve({\n              model,\n              input: inputTokenCount,\n              output: outputTokenCount\n            })\n          } catch (err) {\n            reject(err)\n          } finally {\n            span.end()\n          }\n        })\n\n        // TODO: schema\n\n        return {\n          rawCompletion: fullContentPromise,\n          stream: textStream2,\n          usage: usagePromise,\n        }\n      } catch (err: any) {\n        span.recordException(err)\n        throw err\n      }\n    })\n  }\n\n  private possiblyFixMessageRoles(messages: (ChatMessage | ChatCompletionMessageParam)[]): ChatCompletionMessageParam[] {\n    return fixMessageRoles({ singleSystemMessage: true, forcedRoleAlternation: true }, messages)\n  }\n\n}\n\nregisterProcessor(AnthropicProcessor.label, (opts: Partial<AnthropicProcessorOpts> = {}) => new AnthropicProcessor(opts))\n", "import { nanoid } from \"nanoid\"\nimport type { ZodSchema } from \"zod\"\nimport { EventEmitter } from \"eventemitter3\"\nimport { getProcessor } from \"./processors/registry.js\"\nimport { zodToJsonSchema } from \"zod-to-json-schema\"\nimport type { UsageNumbers } from \"./processors/Processor.js\"\nimport type { MemoryTransformationOptions, PostProcessReturn, TransformOptions, TransformReturnNonStreaming, TransformReturnStreaming } from \"./cognitiveStep.js\"\nimport { indentNicely } from \"./utils.js\"\nimport { ChatMessageRoleEnum, InputMemory, Memory } from \"./Memory.js\"\n\n/**\n * This file defines the structure and operations on working memory within the OPEN SOULS soul-engine.\n * Additionally, it provides interfaces for processor specifications and the handling of memory transformations and cognitive steps.\n * WorkingMemory is crucial for managing the state and interactions within the soul-engine, facilitating the processing and transformation of memory items.\n * See cognitiveStep.ts for more information on cognitive steps and memory transformations.\n */\n\nexport interface ProcessorSpecification {\n  name: string,\n  options?: Record<string, any>\n}\n\nexport interface WorkingMemoryInitOptions {\n  soulName: string\n  memories?: InputMemory[]\n  processor?: ProcessorSpecification\n  /*\n   *  postCloneTransformation is a hook for library developers who want to shape a working memory or provide hooks or defaults on every return of a new working memory. \n   */\n  postCloneTransformation?: (workingMemory: WorkingMemory) => WorkingMemory\n}\n\nexport type MemoryListOrWorkingMemory = InputMemory[] | WorkingMemory\n\nconst defaultPostProcessor = <SchemaType = string>(_workingMemory: WorkingMemory, response: SchemaType): PostProcessReturn<SchemaType> => {\n  const memory = {\n    role: ChatMessageRoleEnum.Assistant,\n    content: (response as any).toString()\n  }\n\n  return [memory, response]\n}\n\ninterface PendingInfo { \n  pending?: Promise<void>\n  pendingResolve?: () => void\n} \n\n// this is the weirdest construct but we need to make sure WorkingMemory is *completely* immutable including\n// anything that is *internally* mutable (pending, usage, memories). So we use these factories to create closures\n// over immutable objects. This way the WorkingMemory is always immutable (the functions do not change), but we can \n// have some state that is mutable within the WorkingMemory itself.\nconst pendingFactory = (): (() => PendingInfo) => {\n  const pending: PendingInfo = {}\n  return () => pending\n}\n\n// see the pending factory for notes here\nconst usageFactory = (): (() => UsageNumbers) => {\n  const usage: UsageNumbers = {\n    model: \"\",\n    input: 0,\n    output: 0,\n  }\n  return () => usage\n}\n\n// see the pending factory for notes here\nconst memoryFactory = (initialMemories?: Memory[]): (() => Memory[]) => {\n  const memories: Memory[] = [...initialMemories || []]\n  return () => memories\n}\n\nexport class WorkingMemory extends EventEmitter {\n  readonly id\n  private _memories: ReturnType<typeof memoryFactory>\n  private _usage: ReturnType<typeof usageFactory>\n  private _postCloneTransformation: (workingMemory: WorkingMemory) => WorkingMemory\n\n  private _pending: ReturnType<typeof pendingFactory>\n\n  soulName: string\n  processor: ProcessorSpecification = Object.freeze({\n    name: \"openai\",\n  })\n\n  constructor({ soulName, memories, postCloneTransformation, processor }: WorkingMemoryInitOptions) {\n    super()\n    this.id = nanoid()\n    this._memories = memoryFactory(this.memoriesFromInputMemories(memories || []))\n    this.soulName = soulName\n    if (processor) {\n      this.processor = processor\n    }\n    this._pending = pendingFactory()\n    this._postCloneTransformation = postCloneTransformation || ((workingMemory) => workingMemory)\n    this._usage = usageFactory()\n  }\n\n  /**\n   * Gets the usage information of input/output tokens for the current WorkingMemory instance.\n   * This information is only available once the WorkingMemory is no longer pending and after a transformation has been performed.\n   * \n   * @returns An object containing the model name, and the number of input and output tokens used.\n   * \n   * @example\n   * ```\n   * const usageInfo = workingMemory.usage;\n   * console.log(`Model: ${usageInfo.model}, Input Tokens: ${usageInfo.input}, Output Tokens: ${usageInfo.output}`);\n   * ```\n   */\n  get usage() {\n    return { ...this._usage() }\n  }\n\n  get memories() {\n    return [...this.internalMemories]\n  }\n\n  /**\n   * The `length` attribute returns the number of memories currently stored in the WorkingMemory instance.\n  * \n   * @returns The total number of memories.\n   * \n   * @example\n   * ```\n   * const workingMemory = new WorkingMemory({ soulName: 'example' });\n   * console.log(workingMemory.length); // Outputs 0 (no memories there)\n   * ```\n   */\n  get length() {\n    return this.internalMemories.length\n  }\n\n  private get internalMemories() {\n    return this._memories()\n  }\n\n  /**\n   * Retrieves a memory at a specified index from the internal memories array.\n   * \n   * @param index - The zero-based index of the memory to retrieve.\n   * @returns The memory object at the specified index, or undefined if the index is out of bounds.\n   * \n   * @example\n   * ```\n   * const memoryAtIndex = workingMemory.at(1);\n   * if (memoryAtIndex) {\n   *   console.log(`Memory at index 1:`, memoryAtIndex);\n   * } else {\n   *   console.log(`No memory found at index 1.`);\n   * }\n   * ```\n   */\n  at(index: number) {\n    return this.internalMemories[index]\n  }\n\n  /**\n   * The `finished` attribute returns a promise which resolves once the current pending transformation using a CognitiveStep is complete.\n   * This is a fairly low level API and most users will not need to worry about this, since working memory uses this attribute internally and\n   * the soul-engine does as well.\n   * \n   * Only streaming cognitive functions will result in WorkingMemory with pending transformations.\n   * \n   * @returns A promise that resolves once the current pending transformation is finished.\n   * \n   * @example\n   * ```\n   * const [workingMemory, stream] = await cognitiveStep(workingMemory, userArgs, { stream: true });\n   * await workingMemory.finished;\n   * console.log('Transformation complete.');\n   * ```\n   * \n   * @example\n   * ```\n   * [workingMemory, stream] = await cognitiveStep(workingMemory, userArgs, { stream: true });\n   * // even though we are not awaiting workingMemory.finished it's ok and will be automatically awaited.\n   * [workingMemory] = await cognitiveStep(workingMemory, userArgs);\n   * // all transformations are complete here.\n   * ```\n   */\n  get finished(): Promise<void> {\n    const pendingObj = this._pending()\n    if (!pendingObj.pending) {\n      return Promise.resolve()\n    }\n    return pendingObj.pending\n  }\n\n  /**\n   * Creates a clone of the current WorkingMemory instance, optionally replacing its memories with new ones.\n   * \n   * @param replacementMemories - An optional array of InputMemory objects to replace the current memories in the clone.\n   *                              If not provided, the clone will retain the original memories.\n   * @returns A new WorkingMemory instance, with optionally replaced memories.\n   * \n   * @example\n   * ```\n   * const originalMemory = new WorkingMemory({ soulName: \"ExampleSoul\", memories: [{...memory}] });\n   * const clonedMemory = originalMemory.clone([optionalNewMemories]);\n   * ```\n   */\n  clone(replacementMemories?: InputMemory[]) {\n    const newMemory = new WorkingMemory({\n      soulName: this.soulName,\n      memories: replacementMemories || this.memories,\n      postCloneTransformation: this._postCloneTransformation,\n      processor: this.processor,\n    })\n    return this._postCloneTransformation(newMemory)\n  }\n\n  /**\n   * Replaces the current memories in the WorkingMemory instance with new ones provided by the caller.\n   * This method is nearly an alias of the `clone` method, with the key difference being that `replacementMemories` are required.\n   * \n   * @param replacementMemories - An array of InputMemory objects to replace the current memories.\n   * @returns A new WorkingMemory instance, with the memories replaced by the provided ones.\n   * \n   * @example\n   * ```\n   * const newMemories = [{...}, {...}];\n   * const updatedMemory = workingMemory.replace(newMemories);\n   * ```\n   */\n  replace(replacementMemories: InputMemory[]) {\n    return this.clone(replacementMemories)\n  }\n\n  /**\n   * Applies a provided function to each memory in the WorkingMemory instance, producing a new WorkingMemory instance.\n   * This method behaves similarly to the Array.prototype.map function, with the key difference being that it returns\n   * a new immutable WorkingMemory instance containing the transformed memories, rather than an array of the transformed items.\n   * \n   * @param callback - A function that accepts up to two arguments. The map method calls the callback function one time for each memory in the WorkingMemory.\n   * @returns A new WorkingMemory instance with each memory transformed by the callback function.\n   * \n   * @example\n   * ```\n   * const newWorkingMemory = workingMemory.map((memory, index) => {\n   *   // Transform the memory here\n   *   return transformedMemory;\n   * });\n   * ```\n   */\n  map(callback: (memory: Memory, i?: number) => InputMemory) {\n    const unfrozenMemories = this.memories.map((memory) => {\n      return {\n        ...memory\n      }\n    })\n    const newMemories = unfrozenMemories.map(callback)\n    return this.clone(newMemories)\n  }\n\n  /**\n   * Applies a provided asynchronous function to each memory in the WorkingMemory instance, producing a new WorkingMemory instance.\n   * This method is similar to the `map` method but allows for asynchronous transformations of each memory. It returns\n   * a new immutable WorkingMemory instance containing the transformed memories, rather than an array of the transformed items.\n   * \n   * @param callback - An asynchronous function that accepts a memory and optional index (number). The asyncMap method calls the callback function one time for each memory in the WorkingMemory.\n   *                   This function should return a Promise that resolves to the transformed memory.\n   * @returns A Promise that resolves to a new WorkingMemory instance with each memory transformed by the asynchronous callback function.\n   * \n   * @example\n   * ```\n   * const newWorkingMemory = await workingMemory.asyncMap(async (memory, index) => {\n   *   // Asynchronously transform the memory here\n   *   return await transformMemoryAsync(memory);\n   * });\n   * ```\n   */\n  async asyncMap(callback: (memory: Memory, i?: number) => Promise<InputMemory>) {\n    const newMemories = await Promise.all(this.memories.map(callback))\n    return this.clone(newMemories)\n  }\n\n  /**\n   * Returns a new WorkingMemory object with the memories sliced from `start` to `end` (`end` not included)\n   * where `start` and `end` represent the index of items in the WorkingMemory's internal memory array. It behaves similarly to the `slice()` method of JavaScript arrays.\n   * \n   * @param start - Zero-based index at which to start extraction. A negative index can be used, indicating an offset from the end of the sequence.\n   * @param end - Zero-based index before which to end extraction. `slice` extracts up to but not including `end`. A negative index can be used, indicating an offset from the end of the sequence.\n   * @returns A new WorkingMemory instance containing the extracted memories.\n   * \n   * @example\n   * ```\n   * const slicedWorkingMemory = workingMemory.slice(1, 3);\n   * ```\n   */\n  slice(start: number, end?: number) {\n    return this.clone(this.internalMemories.slice(start, end))\n  }\n\n  /**\n   * Adds a single memory to the current set of memories in the WorkingMemory instance, producing a new WorkingMemory instance.\n   * \n   * @param memory - The memory to add to the WorkingMemory.\n   * @returns A new WorkingMemory instance with the added memory.\n   * \n   * @example\n   * ```\n   * const newMemory = { role: ChatMessageRoleEnum.User, content: \"Hello, world!\" };\n   * const newWorkingMemory = workingMemory.withMemory(newMemory);\n   * ```\n   */\n  withMemory(memory: InputMemory) {\n    return this.concat(this.normalizeMemoryListOrWorkingMemory([memory]))\n  }\n\n\n  /**\n   * Filters the memories in the WorkingMemory instance using the provided callback, similar to Array.prototype.filter.\n   * This method creates a new WorkingMemory instance with all memories that pass the test implemented by the provided function.\n   * \n   * @param callback - A function that accepts a memory and returns a boolean. If it returns true, the memory is included in the new WorkingMemory instance.\n   * @returns A new WorkingMemory instance with the filtered memories.\n   */\n  filter(callback: (memory: Memory, i?: number) => boolean) {\n    const newMemories = this.memories.filter(callback)\n    return this.clone(newMemories)\n  }\n\n  /**\n   * Tests whether at least one memory in the WorkingMemory instance passes the test implemented by the provided callback, similar to Array.prototype.some.\n   * This method does not modify the WorkingMemory instance.\n   * \n   * @param callback - A function that accepts a memory and returns a boolean.\n   * @returns A boolean indicating whether at least one memory passes the test.\n   */\n  some(callback: (memory: Memory) => boolean) {\n    return this.internalMemories.some(callback)\n  }\n\n  /**\n   * Finds the first memory in the WorkingMemory instance that satisfies the provided testing function, similar to Array.prototype.find.\n   * \n   * @param callback - A function that accepts a memory and returns a boolean. If it returns true, the memory is returned from the method.\n   * @returns The first memory that satisfies the provided testing function, or undefined if no such memory is found.\n   */\n  find(callback: (memory: Memory) => boolean) {\n    const mem = this.memories.find(callback)\n    if (!mem) {\n      return mem\n    }\n    return { ...mem }\n  }\n\n  /**\n   * Concatenates the memories of another WorkingMemory (or an array of Memory objects) to the memories of the current WorkingMemory instance, similar to Array.prototype.concat.\n   * This method creates a new WorkingMemory instance with the concatenated memories.\n   * \n   * @param other - Another WorkingMemory (or an array of Memory innstances) to be concatenate with the current instance.\n   * @returns A new WorkingMemory instance with the concatenated memories.\n   */\n  concat(other: MemoryListOrWorkingMemory) {\n    const otherWorkingMemory = this.normalizeMemoryListOrWorkingMemory(other)\n    return this.clone(this.internalMemories.concat(otherWorkingMemory.memories))\n  }\n\n  /**\n   * Prepends the memories the memories of another WorkingMemory (or an array of Memory objects) to the memories of the current WorkingMemory instance,\n   * This method creates a new WorkingMemory instance with the memories of the other instance followed by the current instance's memories, similar to using WorkingMemory#concat in reverse.\n   * \n   * @param otherWorkingMemory - Another MemoryListOrWorkingMemory instance whose memories are to be prepended to the current instance.\n   * @returns A new WorkingMemory instance with the prepended memories.\n   */\n  prepend(otherWorkingMemory: MemoryListOrWorkingMemory) {\n    const otherMemory = this.normalizeMemoryListOrWorkingMemory(otherWorkingMemory)\n    return this.clone(otherMemory.memories.concat(this.memories))\n  }\n\n  /**\n   * Adds a monologue memory with the role of Assistant and the provided content to the WorkingMemory instance.\n   * This method creates a new WorkingMemory instance with the added monologue memory.\n   * \n   * @param content - The content of the monologue memory to add.\n   * @returns A new WorkingMemory instance with the added monologue memory.\n   */\n  withMonologue(content: string) {\n    return this.withMemory({\n      role: ChatMessageRoleEnum.Assistant,\n      content,\n    })\n  }\n\n  /**\n   * Transforms the WorkingMemory using a specified processor and returns a new WorkingMemory instance along with the results of the transformation.\n   * This function is a low-level API that is rarely used directly by users. Instead, users typically interact with CognitiveSteps defined in ./cognitiveStep.\n   * The transformation can operate in two modes, determined by the `stream` option in the `opts` parameter:\n   * - If `stream: true` is passed, the function returns a stream of transformed data.\n   * - Otherwise, it returns a single transformed result.\n   * \n   * @param transformation - The transformation options to apply, including the processor to use.\n   * @param opts - Options for the transformation, including whether to use streaming.\n   * @returns A Promise resolving to a new WorkingMemory instance and the results of the transformation. The nature of the results depends on the `stream` option.\n   */\n  async transform<SchemaType, PostProcessType>(transformation: MemoryTransformationOptions<SchemaType, PostProcessType>, opts: { stream: true } & TransformOptions): Promise<TransformReturnStreaming<PostProcessType>>;\n  async transform<SchemaType, PostProcessType>(transformation: MemoryTransformationOptions<SchemaType, PostProcessType>, opts?: Omit<TransformOptions, 'stream'>): Promise<TransformReturnNonStreaming<PostProcessType>>;\n  async transform<SchemaType, PostProcessType>(transformation: MemoryTransformationOptions<SchemaType, PostProcessType>, opts?: { stream: false } & Omit<TransformOptions, 'stream'>): Promise<TransformReturnNonStreaming<PostProcessType>>;\n  async transform<SchemaType, PostProcessType>(transformation: MemoryTransformationOptions<SchemaType, PostProcessType>, opts: TransformOptions = {}) {\n    await this.finished\n\n    const newMemory = this.clone()\n    newMemory.markPending()\n\n    return newMemory.doTransform<SchemaType, PostProcessType>(transformation, opts)\n  }\n\n  /**\n   * Returns a string representation of the internal memories of the WorkingMemory instance.\n   * This method formats the internal memories into a readable string, showcasing each memory in a JSON stringified format.\n   * \n   * @returns A string that represents the internal memories of the WorkingMemory instance.\n   */\n  toString() {\n    return indentNicely`\n      Working Memory (${this.id}): ${this.soulName}\n      Memories:\n      ${this.internalMemories.map((memory) => {\n        return JSON.stringify(memory)\n      }).join(\"\\n\")}\n    `\n  }\n\n  protected markPending() {\n    const pendingInfo = this._pending()\n    if (pendingInfo.pending) {\n      throw new Error(\"attempting to mark pending a working memory already marked as pending\")\n    }\n    pendingInfo.pending = new Promise((res) => {\n      pendingInfo.pendingResolve = res\n    })\n  }\n\n  protected resolvePending() {\n    const pendingInfo = this._pending()\n\n    if (!pendingInfo.pendingResolve) {\n      throw new Error('attempting to resolve pending on a memory that is not pending')\n    }\n    pendingInfo.pendingResolve()\n    pendingInfo.pending = undefined\n    pendingInfo.pendingResolve = undefined\n  }\n\n  protected async doTransform<SchemaType, PostProcessType>(transformation: MemoryTransformationOptions<SchemaType, PostProcessType>, opts: TransformOptions) {\n    if (!this._pending().pending) {\n      throw new Error(\"attempting to update working memory not marked as pending\")\n    }\n    try {\n      const {\n        postProcess = defaultPostProcessor<SchemaType>,\n        command,\n        schema,\n        skipAutoSchemaAddition,\n        streamProcessor,\n      } = transformation\n\n      const processorSpec = opts.processor || this.processor\n\n      const processor = getProcessor(processorSpec.name, processorSpec.options)\n\n      const commandMemory = typeof command === \"string\" ? {\n        role: ChatMessageRoleEnum.System,\n        content: command\n      } : command(this)\n\n      if (schema && !skipAutoSchemaAddition) {\n        commandMemory.content += \"\\n\\n\" + indentNicely`\n          Respond *only* in JSON, conforming to the following JSON schema:\n          ${JSON.stringify(zodToJsonSchema(schema), null, 2)}\n        `\n      }\n\n      const memoryWithCommand = this.withMemory(commandMemory)\n\n      const response = await processor.process<SchemaType>({\n        memory: memoryWithCommand,\n        schema: (schema as ZodSchema<SchemaType>),\n        ...opts,\n      })\n\n      if (opts.stream) {\n        const valuePromise = new Promise(async (resolve, reject) => {\n          try {\n            const [memory, value] = await postProcess(this, await response.parsed)\n            this.internalMemories.push(...this.memoriesFromInputMemories([memory]))\n            const usageNumbers = await response.usage\n            const usageObj = this._usage()\n            Object.entries(usageNumbers).forEach(([key, value]) => {\n              (usageObj as any)[key] = value\n            })\n            resolve(value)\n          } catch (err) {\n            reject(err)\n          } finally {\n            this.resolvePending()\n          }\n        })\n\n        const stream = streamProcessor ? await streamProcessor(this, response.stream) : response.stream\n        return [this, stream, valuePromise]\n      }\n\n      const [memory, value] = await postProcess(this, await response.parsed)\n      this.internalMemories.push(...this.memoriesFromInputMemories([memory]))\n      const usageNumbers = await response.usage\n\n      const usageObj = this._usage()\n      Object.entries(usageNumbers).forEach(([key, value]) => {\n        (usageObj as any)[key] = value\n      })\n      this.resolvePending()\n\n      return [this, value]\n    } catch (err) {\n      console.error(\"error in doTransform\", err)\n      this.resolvePending()\n      throw err\n    }\n  }\n\n  private memoriesFromInputMemories(memories: InputMemory[]) {\n    return memories.map((memory) => {\n      return {\n        ...memory,\n        _id: memory._id || nanoid(),\n        _timestamp: memory._timestamp || Date.now()\n      }\n    })\n  }\n\n  private normalizeMemoryListOrWorkingMemory(memories: MemoryListOrWorkingMemory) {\n    if (memories instanceof WorkingMemory) {\n      return memories\n    }\n    return this.clone(memories)\n  }\n}\n", "export enum SoulEventKinds {\n  Perception = \"perception\",\n  InteractionRequest = \"interactionRequest\",\n  System = \"system\",\n}\n\nexport type Json =\n  | { [key: string]: Json | undefined }\n  | Json[]\n  | boolean\n  | null\n  | number\n  | string\n  | undefined\n\nexport interface SoulEvent {\n  _id: string\n  _kind: SoulEventKinds\n  _timestamp: number // miliseconds since epoch\n  _metadata?: Record<string, Json>\n  _pending?: boolean\n  internal?: boolean\n  _mentalProcess?: {\n    name: string\n    params: Json\n  }\n\n  action: string\n  content: string\n  name?: string,\n}\n\nexport interface PerceptionBase extends SoulEvent {\n  _kind: SoulEventKinds.Perception\n}\n\nexport interface ExternalPerception extends PerceptionBase {\n  internal?: false,\n}\n\nexport interface InternalPerception extends PerceptionBase {\n  internal: true,\n  premonition?: string,\n}\n\nexport type Perception = ExternalPerception | InternalPerception\n\nexport type DeveloperDispatchedPerception = Omit<ExternalPerception, \"_id\" | \"_kind\" | \"_timestamp\">\n\nexport interface InteractionRequest extends SoulEvent {\n  _kind: SoulEventKinds.InteractionRequest\n}\n\n// this is what the developer is actually sending, the missing fields get filled in by the system.\nexport type DeveloperInteractionRequest = Omit<InteractionRequest, \"_id\" | \"_kind\" | \"_timestamp\" | \"content\" | \"internal\"> & {\n  content: AsyncIterable<string> | string\n}\n\nexport interface SystemEvent extends SoulEvent {\n  _kind: SoulEventKinds.System\n}\n\nexport type SoulEnvironment = Record<string, Json> | undefined\n\n\nexport interface JsonRPCCall {\n  id: string\n  method: string\n  params: any\n}\n\nexport interface SuccessfulJsonRPCResponse {\n  id: string\n  result: Json\n}\n\nexport interface ErroredJsonRPCResponse {\n  id: string\n  error: {\n    code: number\n    message: string\n    data?: Json\n  }\n}\n\nexport type JsonRPCResponse = SuccessfulJsonRPCResponse | ErroredJsonRPCResponse\n\nexport interface JsonRPCPair {\n  request: JsonRPCCall\n  response?: JsonRPCResponse\n}\n\nexport interface EventLogMetadata {\n  id: string,\n  blueprint?: string,\n  environment?: SoulEnvironment,\n}\n\nexport const eventLogShape = {\n  events: [] as SoulEvent[],\n  metadata: {} as EventLogMetadata,\n  pendingToolCalls: {} as Record<string, JsonRPCPair>\n}\n\nexport type EventLogDoc = typeof eventLogShape\n\nexport const debugChatShape = {\n  metadata: {},\n  state: {},\n  eventLog: {} as EventLogDoc,\n}\n"],
  "mappings": "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",
  "names": ["ChatMessageRoleEnum", "messages", "trace", "context", "backOff", "tracer", "trace", "memoryToChatMessage", "chunkStreamToTextStream", "DEFAULT_MODEL", "context", "backOff", "memory", "value", "usageNumbers", "usageObj", "SoulEventKinds"]
}
