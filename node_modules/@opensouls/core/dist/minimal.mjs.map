{
  "version": 3,
  "sources": ["../src/minimal.ts", "../src/cognitiveStep.ts", "../src/forkStream.ts", "../src/utils.ts", "../src/Memory.ts"],
  "sourcesContent": ["export { z } from 'zod';\n\nexport * from './cognitiveStep.js'\nexport * from './forkStream.js'\nexport * from './utils.js'\nexport * from \"./Memory.js\"", "import type { ZodSchema } from \"zod\"\nimport type { ProcessorSpecification, WorkingMemory } from \"./WorkingMemory.js\"\nimport type { RequestOptions } from \"./processors/Processor.js\"\nimport { InputMemory } from \"./Memory.js\"\n\nexport type StreamProcessor = (workingMemory: WorkingMemory, stream: AsyncIterable<string>) => (AsyncIterable<string> | Promise<AsyncIterable<string>>)\n\nexport type PostProcessReturn<SchemaType> = [InputMemory, SchemaType]\n\nexport interface MemoryTransformationOptions<SchemaType = string, PostProcessType = SchemaType> {\n  command: string | ((workingMemory: WorkingMemory) => InputMemory)\n\n  processor?: string\n  schema?: ZodSchema<SchemaType>\n  postProcess?: (originalMemory: WorkingMemory, response: SchemaType) => (Promise<PostProcessReturn<PostProcessType>> | PostProcessReturn<PostProcessType>)\n  streamProcessor?: StreamProcessor\n  skipAutoSchemaAddition?: boolean\n}\n\nexport type TransformOptions =\n  RequestOptions &\n  {\n    stream?: boolean\n    processor?: ProcessorSpecification\n  }\n\nexport type TransformReturnStreaming<PostProcessType> = [WorkingMemory, AsyncIterable<string>, Promise<PostProcessType>]\nexport type TransformReturnNonStreaming<PostProcessType> = [WorkingMemory, PostProcessType]\nexport type TransformReturn<PostProcessType> = TransformReturnStreaming<PostProcessType> | TransformReturnNonStreaming<PostProcessType>\n\nexport type CognitiveStep<UserArgType, PostProcessReturnType> = {\n  (memory: WorkingMemory, userArgs: UserArgType, transformOpts: TransformOptions & { stream: true }): Promise<TransformReturnStreaming<PostProcessReturnType>>\n  (memory: WorkingMemory, userArgs: UserArgType, transformOpts?: Omit<TransformOptions, \"stream\">): Promise<TransformReturnNonStreaming<PostProcessReturnType>>\n  (memory: WorkingMemory, userArgs: UserArgType, transformOpts: Omit<TransformOptions, \"stream\"> & { stream: false }): Promise<TransformReturnNonStreaming<PostProcessReturnType>>\n}\n\n/**\n * Creates a new CognitiveStep function configured with the specified transformation logic.\n * This function is pivotal in the cognitive processing pipeline, allowing for dynamic\n * transformation of working memory based on user-defined logic and conditions.\n *\n * @param transformationOptionsGenerator A callback function that takes a single argument and returns a `MemoryTransformationOptions` object.\n *           This callback defines the transformation logic applied in the cognitive step.\n *           The single argument can be any user-defined data structure or value that the callback\n *           uses to determine the transformation logic.\n * @returns A `CognitiveStep` function that takes a `WorkingMemory` instance, user arguments, and\n *          request options. It applies the transformation logic defined by the `transformationOptionsGenerator` callback\n *          to the working memory and returns the transformed memory along with any post-processing results.\n *          The function supports both streaming and non-streaming modes based on the provided request options.\n *\n * Trivial exmaple:\n * Defines a CognitiveStep that answers a user's question in a single word.\n * The transformation logic includes a command as a string, a schema to validate the response using Zod, and a post-processing function that converts the response to uppercase.\n * This cognitive step is then used to transform the working memory based on user arguments and transformation options, supporting both streaming and non-streaming modes.\n * ```\n * const myCognitiveStep = createCognitiveStep((singleArg) => ({\n *   command: \"Answer the user's question in a single word.\",\n *   schema: z.object({ answer: z.string() }),\n *   postProcess: async (originalMemory, response) => [originalMemory, response.toUpperCase()],\n * }));\n *\n * // To use the cognitive step:\n * const [newMemory, result] = await myCognitiveStep(workingMemory, userArgs);\n * // or\n * const [newMemory, stream, resultPromise] = await myCognitiveStep(workingMemory, userArgs, { stream: true })\n * ```\n */\nexport const createCognitiveStep =\n  <UserArgType = undefined, SchemaType = string, PostProcessType = SchemaType>(\n    transformationOptionsGenerator: (singleArg: UserArgType) => MemoryTransformationOptions<SchemaType, PostProcessType>\n  ): CognitiveStep<UserArgType, PostProcessType> => {\n\n    return (async (workingMemory: WorkingMemory, singleArg: UserArgType, opts: TransformOptions = {}) => {\n      const transformOpts = transformationOptionsGenerator(singleArg)\n      return workingMemory.transform(transformOpts, opts)\n    }) as CognitiveStep<UserArgType, PostProcessType>\n  }\n", "import { ReadableStream } from 'web-streams-polyfill';\n\nexport function forkStream<T>(originalStream: AsyncIterable<T>, count = 2): ReadableStream<T>[] {\n  const streams = Array.from({ length: count }, () => {\n    let controller: { current: ReadableStreamDefaultController<T> | null } = { current: null };\n\n    const stream = new ReadableStream<T>({\n      start(c) {\n        controller.current = c;\n      },\n      cancel() {\n        console.log('Stream was cancelled.');\n      }\n    });\n\n    return {\n      stream,\n      controller\n    };\n  });\n\n  const processStream = async () => {\n    try {\n      for await (const chunk of originalStream) {\n        streams.forEach(({ stream, controller }) => {\n          if (controller.current) {\n            controller.current.enqueue(chunk);\n          }\n        });\n      }\n      streams.forEach(({ stream, controller }) => {\n        if (controller.current) {\n          controller.current.close();\n        }\n      });\n    } catch (err) {\n      console.error('Error processing stream:', err);\n      streams.forEach(({ stream, controller }) => {\n        if (controller.current) {\n          controller.current.error(err);\n        }\n      });\n    }\n  };\n\n  processStream();\n\n  return streams.map(({ stream }) => stream);\n}", "import type { WorkingMemory } from \"./WorkingMemory.js\";\nimport { codeBlock } from \"common-tags\"\n\nexport const indentNicely = codeBlock\n\nexport const stripEntityAndVerb = (soulName: string, _verb: string, response: string) => {\n  // sometimes the LLM will respond with something like \"Bogus said with a sinister smile: \"I'm going to eat you!\" (adding more words)\n  // so we just strip any of those\n  let strippedResponse = response.replace(new RegExp(`${soulName}.*?:`, \"i\"), \"\").trim();\n  // get rid of the quotes\n  strippedResponse = strippedResponse.replace(/^[\"']|[\"']$/g, '').trim();\n  return strippedResponse\n}\n\nexport const stripEntityAndVerbFromStream = async ({ soulName }: WorkingMemory, stream: AsyncIterable<string>): Promise<AsyncIterable<string>> => {\n  const prefix = new RegExp(`^${soulName}.*?:\\\\s*[\"']*`, \"i\")\n  const suffix = /[\"']$/\n\n  let isStreaming = !prefix\n  let prefixMatched = !prefix\n  let buffer = \"\"\n  const isStreamingBuffer: string[] = []\n\n  const processedStream = (async function* () {\n    for await (const chunk of stream) {\n      // if we are already streaming, then we need to look out for a suffix\n      // we keep the last 2 chunks in the buffer to check after the stream is finished\n      // othwerwise we keep streaming\n      if (isStreaming) {\n        if (!suffix) {\n          yield chunk\n          continue;\n        }\n        isStreamingBuffer.push(chunk)\n        if (isStreamingBuffer.length > 2) {\n          yield isStreamingBuffer.shift() as string\n        }\n        continue;\n      }\n\n      // if we're not streaming, then keep looking for the prefix, and allow one *more* chunk\n      // after detecting a hit on the prefix to come in, in case the prefix has some optional ending\n      // characters.\n      buffer += chunk;\n      if (prefix && prefix.test(buffer)) {\n        if (prefixMatched) {\n          isStreaming = true;\n\n          buffer = buffer.replace(prefix, '');\n          yield buffer; // yield everything after the prefix\n          buffer = ''; // clear the buffer\n          continue\n        }\n        prefixMatched = true\n      }\n    }\n    buffer = [buffer, ...isStreamingBuffer].join('')\n    // if we ended before switching on streaming, then we haven't stripped the prefix yet.\n    if (!isStreaming && prefix) {\n      buffer = buffer.replace(prefix, '');\n    }\n    if (buffer.length > 0) {\n      // if there was some buffer left over, then we need to check if there was a suffix\n      // and remove that from the last part of the stream.\n      if (suffix) {\n        buffer = buffer.replace(suffix, '');\n        yield buffer; // yield everything before the suffix\n        return\n      }\n      // if there was no suffix, then just yield what's left.\n      yield buffer; // yield the last part of the buffer if anything is left\n    }\n  })();\n  return processedStream;\n}\n", "\nexport enum ChatMessageRoleEnum {\n  System = \"system\",\n  User = \"user\",\n  Assistant = \"assistant\",\n  Function = \"function\",\n}\n\nexport interface ImageURL {\n  /**\n   * Either a URL of the image or the base64 encoded image data.\n   */\n  url: string;\n\n  /**\n   * Specifies the detail level of the image. Learn more in the\n   * [Vision guide](https://platform.openai.com/docs/guides/vision/low-or-high-fidelity-image-understanding).\n   */\n  detail?: 'auto' | 'low' | 'high';\n}\n\nexport type ContentText = { type: \"text\", text: string }\nexport type ContentImage = { type: \"image_url\", image_url: ImageURL }\n\nexport type ChatMessageContent = string | (ContentText | ContentImage)[]\n\nexport interface Memory<MetaDataType = Record<string, unknown>> {\n  role: ChatMessageRoleEnum;\n  content: ChatMessageContent;\n  name?: string;\n  metadata?: MetaDataType;\n\n  _id: string;\n  _timestamp: number;\n}\n\nexport type InputMemory = Omit<Memory, \"_id\" | \"_timestamp\"> & { _id?: string, _timestamp?: number }\n"],
  "mappings": "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",
  "names": ["ChatMessageRoleEnum"]
}
