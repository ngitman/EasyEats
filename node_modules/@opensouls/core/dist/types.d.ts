import Anthropic from '@anthropic-ai/sdk';
import { ChatMessageContent as ChatMessageContent_2 } from './Memory.js';
import { EventEmitter } from 'eventemitter3';
import OpenAI from 'openai';
import { ReadableStream as ReadableStream_2 } from 'web-streams-polyfill';
import { RequestOptions as RequestOptions_2 } from 'openai/core';
import { TemplateTag } from 'common-tags';
import { z } from 'zod';
import { ZodSchema } from 'zod';

export declare type AnthropicClientConfig = ConstructorParameters<typeof Anthropic>[0];

export declare type AnthropicCompletionParams = Anthropic["messages"]["stream"]["arguments"][0];

export declare type AnthropicDefaultCompletionParams = AnthropicCompletionParams & {
    model: AnthropicCompletionParams["model"] | string;
};

export declare class AnthropicProcessor implements Processor {
    static label: string;
    private client;
    private defaultRequestOptions;
    private defaultCompletionParams;
    constructor({ clientOptions, defaultRequestOptions, defaultCompletionParams, customClient }: AnthropicProcessorOpts);
    process<SchemaType = string>(opts: ProcessOpts<SchemaType>): Promise<ProcessResponse<SchemaType>>;
    private execute;
    private possiblyFixMessageRoles;
}

export declare interface AnthropicProcessorOpts {
    clientOptions?: AnthropicClientConfig;
    defaultCompletionParams?: Partial<AnthropicDefaultCompletionParams>;
    defaultRequestOptions?: Partial<AnthropicRequestOptions>;
    customClient?: ICompatibleAnthropicClient;
}

export declare type AnthropicRequestOptions = Anthropic["messages"]["stream"]["arguments"][1];

export declare type ChatMessageContent = string | (ContentText | ContentImage)[];

export declare enum ChatMessageRoleEnum {
    System = "system",
    User = "user",
    Assistant = "assistant",
    Function = "function"
}

export declare type CognitiveStep<UserArgType, PostProcessReturnType> = {
    (memory: WorkingMemory, userArgs: UserArgType, transformOpts: TransformOptions & {
        stream: true;
    }): Promise<TransformReturnStreaming<PostProcessReturnType>>;
    (memory: WorkingMemory, userArgs: UserArgType, transformOpts?: Omit<TransformOptions, "stream">): Promise<TransformReturnNonStreaming<PostProcessReturnType>>;
    (memory: WorkingMemory, userArgs: UserArgType, transformOpts: Omit<TransformOptions, "stream"> & {
        stream: false;
    }): Promise<TransformReturnNonStreaming<PostProcessReturnType>>;
};

export declare type CompatibleAnthropicClient = {
    messages: {
        stream: (body: AnthropicCompletionParams, options?: AnthropicRequestOptions) => AsyncIterable<Anthropic.MessageStreamEvent>;
    };
};

export declare type ContentImage = {
    type: "image_url";
    image_url: ImageURL;
};

export declare type ContentText = {
    type: "text";
    text: string;
};

/**
 * Creates a new CognitiveStep function configured with the specified transformation logic.
 * This function is pivotal in the cognitive processing pipeline, allowing for dynamic
 * transformation of working memory based on user-defined logic and conditions.
 *
 * @param transformationOptionsGenerator A callback function that takes a single argument and returns a `MemoryTransformationOptions` object.
 *           This callback defines the transformation logic applied in the cognitive step.
 *           The single argument can be any user-defined data structure or value that the callback
 *           uses to determine the transformation logic.
 * @returns A `CognitiveStep` function that takes a `WorkingMemory` instance, user arguments, and
 *          request options. It applies the transformation logic defined by the `transformationOptionsGenerator` callback
 *          to the working memory and returns the transformed memory along with any post-processing results.
 *          The function supports both streaming and non-streaming modes based on the provided request options.
 *
 * Trivial exmaple:
 * Defines a CognitiveStep that answers a user's question in a single word.
 * The transformation logic includes a command as a string, a schema to validate the response using Zod, and a post-processing function that converts the response to uppercase.
 * This cognitive step is then used to transform the working memory based on user arguments and transformation options, supporting both streaming and non-streaming modes.
 * ```
 * const myCognitiveStep = createCognitiveStep((singleArg) => ({
 *   command: "Answer the user's question in a single word.",
 *   schema: z.object({ answer: z.string() }),
 *   postProcess: async (originalMemory, response) => [originalMemory, response.toUpperCase()],
 * }));
 *
 * // To use the cognitive step:
 * const [newMemory, result] = await myCognitiveStep(workingMemory, userArgs);
 * // or
 * const [newMemory, stream, resultPromise] = await myCognitiveStep(workingMemory, userArgs, { stream: true })
 * ```
 */
export declare const createCognitiveStep: <UserArgType = undefined, SchemaType = string, PostProcessType = SchemaType>(transformationOptionsGenerator: (singleArg: UserArgType) => MemoryTransformationOptions<SchemaType, PostProcessType>) => CognitiveStep<UserArgType, PostProcessType>;

export declare const debugChatShape: {
    metadata: {};
    state: {};
    eventLog: {
        events: SoulEvent[];
        metadata: EventLogMetadata;
        pendingToolCalls: Record<string, JsonRPCPair>;
    };
};

export declare type DeveloperDispatchedPerception = Omit<ExternalPerception, "_id" | "_kind" | "_timestamp">;

export declare type DeveloperInteractionRequest = Omit<InteractionRequest, "_id" | "_kind" | "_timestamp" | "content" | "internal"> & {
    content: AsyncIterable<string> | string;
};

export declare interface ErroredJsonRPCResponse {
    id: string;
    error: {
        code: number;
        message: string;
        data?: Json;
    };
}

export declare type EventLogDoc = typeof eventLogShape;

export declare interface EventLogMetadata {
    id: string;
    blueprint?: string;
    environment?: SoulEnvironment;
}

export declare const eventLogShape: {
    events: SoulEvent[];
    metadata: EventLogMetadata;
    pendingToolCalls: Record<string, JsonRPCPair>;
};

export declare interface ExternalPerception extends PerceptionBase {
    internal?: false;
}

export declare function extractJSON(str?: string | null): string | null;

export declare function forkStream<T>(originalStream: AsyncIterable<T>, count?: number): ReadableStream_2<T>[];

export declare function getProcessor(name: string, opts?: ProcessorCreationOpts): Processor;

declare type Headers_2 = Record<string, string | null | undefined>;
export { Headers_2 as Headers }

export declare interface ICompatibleAnthropicClient {
    new (options: AnthropicClientConfig): CompatibleAnthropicClient;
}

export declare interface ImageURL {
    /**
     * Either a URL of the image or the base64 encoded image data.
     */
    url: string;
    /**
     * Specifies the detail level of the image. Learn more in the
     * [Vision guide](https://platform.openai.com/docs/guides/vision/low-or-high-fidelity-image-understanding).
     */
    detail?: 'auto' | 'low' | 'high';
}

export declare const indentNicely: TemplateTag;

export declare type InputMemory = Omit<Memory, "_id" | "_timestamp"> & {
    _id?: string;
    _timestamp?: number;
};

export declare interface InteractionRequest extends SoulEvent {
    _kind: SoulEventKinds.InteractionRequest;
}

export declare interface InternalPerception extends PerceptionBase {
    internal: true;
    premonition?: string;
}

export declare type Json = {
    [key: string]: Json | undefined;
} | Json[] | boolean | null | number | string | undefined;

export declare interface JsonRPCCall {
    id: string;
    method: string;
    params: any;
}

export declare interface JsonRPCPair {
    request: JsonRPCCall;
    response?: JsonRPCResponse;
}

export declare type JsonRPCResponse = SuccessfulJsonRPCResponse | ErroredJsonRPCResponse;

export declare interface Memory<MetaDataType = Record<string, unknown>> {
    role: ChatMessageRoleEnum;
    content: ChatMessageContent;
    name?: string;
    metadata?: MetaDataType;
    _id: string;
    _timestamp: number;
}

export declare type MemoryListOrWorkingMemory = InputMemory[] | WorkingMemory;

export declare interface MemoryTransformationOptions<SchemaType = string, PostProcessType = SchemaType> {
    command: string | ((workingMemory: WorkingMemory) => InputMemory);
    processor?: string;
    schema?: ZodSchema<SchemaType>;
    postProcess?: (originalMemory: WorkingMemory, response: SchemaType) => (Promise<PostProcessReturn<PostProcessType>> | PostProcessReturn<PostProcessType>);
    streamProcessor?: StreamProcessor;
    skipAutoSchemaAddition?: boolean;
}

export declare type OpenAIClientConfig = ConstructorParameters<typeof OpenAI>[0];

export declare class OpenAIProcessor implements Processor {
    static label: string;
    private client;
    private singleSystemMessage;
    private forcedRoleAlternation;
    private disableResponseFormat;
    private defaultRequestOptions;
    private defaultCompletionParams;
    constructor({ clientOptions, singleSystemMessage, forcedRoleAlternation, defaultRequestOptions, defaultCompletionParams, disableResponseFormat }: OpenAIProcessorOpts);
    process<SchemaType = string>(opts: ProcessOpts<SchemaType>): Promise<ProcessResponse<SchemaType>>;
    private execute;
    private possiblyFixMessageRoles;
}

export declare interface OpenAIProcessorOpts {
    clientOptions?: OpenAIClientConfig;
    defaultCompletionParams?: Partial<OpenAI.Chat.Completions.ChatCompletionCreateParams>;
    defaultRequestOptions?: Partial<RequestOptions_2>;
    singleSystemMessage?: boolean;
    forcedRoleAlternation?: boolean;
    disableResponseFormat?: boolean;
}

export declare type Perception = ExternalPerception | InternalPerception;

export declare interface PerceptionBase extends SoulEvent {
    _kind: SoulEventKinds.Perception;
}

export declare type PostProcessReturn<SchemaType> = [InputMemory, SchemaType];

export declare const prepareMemoryForJSON: (workingMemory: WorkingMemory, jsonMessage?: string) => WorkingMemory;

export declare interface ProcessOpts<SchemaType = string> extends RequestOptions {
    memory: WorkingMemory;
    schema?: ZodSchema<SchemaType>;
}

export declare interface Processor {
    process<SchemaType = string>(opts: ProcessOpts<SchemaType>): Promise<ProcessResponse<SchemaType>>;
}

export declare interface ProcessorCreationOpts {
}

export declare type ProcessorFactory = (opts?: ProcessorCreationOpts) => Processor;

/**
 * This file defines the structure and operations on working memory within the OPEN SOULS soul-engine.
 * Additionally, it provides interfaces for processor specifications and the handling of memory transformations and cognitive steps.
 * WorkingMemory is crucial for managing the state and interactions within the soul-engine, facilitating the processing and transformation of memory items.
 * See cognitiveStep.ts for more information on cognitive steps and memory transformations.
 */
export declare interface ProcessorSpecification {
    name: string;
    options?: Record<string, any>;
}

export declare interface ProcessResponse<SchemaType = string> {
    rawCompletion: Promise<string>;
    parsed: Promise<SchemaType>;
    stream: AsyncIterable<string>;
    usage: Promise<UsageNumbers>;
}

export declare function registerProcessor(name: string, processor: ProcessorFactory): void;

export declare interface RequestOptions {
    model?: string;
    temperature?: number;
    maxTokens?: number;
    signal?: AbortSignal;
    tags?: Record<string, string>;
    timeout?: number;
    headers?: Headers_2;
    additionalRequestOptions?: Record<string, any>;
}

export declare type SoulEnvironment = Record<string, Json> | undefined;

export declare interface SoulEvent {
    _id: string;
    _kind: SoulEventKinds;
    _timestamp: number;
    _metadata?: Record<string, Json>;
    _pending?: boolean;
    internal?: boolean;
    _mentalProcess?: {
        name: string;
        params: Json;
    };
    action: string;
    content: string;
    name?: string;
}

export declare enum SoulEventKinds {
    Perception = "perception",
    InteractionRequest = "interactionRequest",
    System = "system"
}

export declare type StreamProcessor = (workingMemory: WorkingMemory, stream: AsyncIterable<string>) => (AsyncIterable<string> | Promise<AsyncIterable<string>>);

export declare const stripEntityAndVerb: (soulName: string, _verb: string, response: string) => string;

export declare const stripEntityAndVerbFromStream: ({ soulName }: WorkingMemory, stream: AsyncIterable<string>) => Promise<AsyncIterable<string>>;

export declare interface SuccessfulJsonRPCResponse {
    id: string;
    result: Json;
}

export declare interface SystemEvent extends SoulEvent {
    _kind: SoulEventKinds.System;
}

export declare type TransformOptions = RequestOptions & {
    stream?: boolean;
    processor?: ProcessorSpecification;
};

export declare type TransformReturn<PostProcessType> = TransformReturnStreaming<PostProcessType> | TransformReturnNonStreaming<PostProcessType>;

export declare type TransformReturnNonStreaming<PostProcessType> = [WorkingMemory, PostProcessType];

export declare type TransformReturnStreaming<PostProcessType> = [WorkingMemory, AsyncIterable<string>, Promise<PostProcessType>];

export declare interface UsageNumbers {
    model: string;
    input: number;
    output: number;
}

export declare class WorkingMemory extends EventEmitter {
    readonly id: string;
    private _memories;
    private _usage;
    private _postCloneTransformation;
    private _pending;
    soulName: string;
    processor: ProcessorSpecification;
    constructor({ soulName, memories, postCloneTransformation, processor }: WorkingMemoryInitOptions);
    /**
     * Gets the usage information of input/output tokens for the current WorkingMemory instance.
     * This information is only available once the WorkingMemory is no longer pending and after a transformation has been performed.
     *
     * @returns An object containing the model name, and the number of input and output tokens used.
     *
     * @example
     * ```
     * const usageInfo = workingMemory.usage;
     * console.log(`Model: ${usageInfo.model}, Input Tokens: ${usageInfo.input}, Output Tokens: ${usageInfo.output}`);
     * ```
     */
    get usage(): {
        model: string;
        input: number;
        output: number;
    };
    get memories(): Memory<Record<string, unknown>>[];
    /**
     * The `length` attribute returns the number of memories currently stored in the WorkingMemory instance.
     *
     * @returns The total number of memories.
     *
     * @example
     * ```
     * const workingMemory = new WorkingMemory({ soulName: 'example' });
     * console.log(workingMemory.length); // Outputs 0 (no memories there)
     * ```
     */
    get length(): number;
    private get internalMemories();
    /**
     * Retrieves a memory at a specified index from the internal memories array.
     *
     * @param index - The zero-based index of the memory to retrieve.
     * @returns The memory object at the specified index, or undefined if the index is out of bounds.
     *
     * @example
     * ```
     * const memoryAtIndex = workingMemory.at(1);
     * if (memoryAtIndex) {
     *   console.log(`Memory at index 1:`, memoryAtIndex);
     * } else {
     *   console.log(`No memory found at index 1.`);
     * }
     * ```
     */
    at(index: number): Memory<Record<string, unknown>>;
    /**
     * The `finished` attribute returns a promise which resolves once the current pending transformation using a CognitiveStep is complete.
     * This is a fairly low level API and most users will not need to worry about this, since working memory uses this attribute internally and
     * the soul-engine does as well.
     *
     * Only streaming cognitive functions will result in WorkingMemory with pending transformations.
     *
     * @returns A promise that resolves once the current pending transformation is finished.
     *
     * @example
     * ```
     * const [workingMemory, stream] = await cognitiveStep(workingMemory, userArgs, { stream: true });
     * await workingMemory.finished;
     * console.log('Transformation complete.');
     * ```
     *
     * @example
     * ```
     * [workingMemory, stream] = await cognitiveStep(workingMemory, userArgs, { stream: true });
     * // even though we are not awaiting workingMemory.finished it's ok and will be automatically awaited.
     * [workingMemory] = await cognitiveStep(workingMemory, userArgs);
     * // all transformations are complete here.
     * ```
     */
    get finished(): Promise<void>;
    /**
     * Creates a clone of the current WorkingMemory instance, optionally replacing its memories with new ones.
     *
     * @param replacementMemories - An optional array of InputMemory objects to replace the current memories in the clone.
     *                              If not provided, the clone will retain the original memories.
     * @returns A new WorkingMemory instance, with optionally replaced memories.
     *
     * @example
     * ```
     * const originalMemory = new WorkingMemory({ soulName: "ExampleSoul", memories: [{...memory}] });
     * const clonedMemory = originalMemory.clone([optionalNewMemories]);
     * ```
     */
    clone(replacementMemories?: InputMemory[]): WorkingMemory;
    /**
     * Replaces the current memories in the WorkingMemory instance with new ones provided by the caller.
     * This method is nearly an alias of the `clone` method, with the key difference being that `replacementMemories` are required.
     *
     * @param replacementMemories - An array of InputMemory objects to replace the current memories.
     * @returns A new WorkingMemory instance, with the memories replaced by the provided ones.
     *
     * @example
     * ```
     * const newMemories = [{...}, {...}];
     * const updatedMemory = workingMemory.replace(newMemories);
     * ```
     */
    replace(replacementMemories: InputMemory[]): WorkingMemory;
    /**
     * Applies a provided function to each memory in the WorkingMemory instance, producing a new WorkingMemory instance.
     * This method behaves similarly to the Array.prototype.map function, with the key difference being that it returns
     * a new immutable WorkingMemory instance containing the transformed memories, rather than an array of the transformed items.
     *
     * @param callback - A function that accepts up to two arguments. The map method calls the callback function one time for each memory in the WorkingMemory.
     * @returns A new WorkingMemory instance with each memory transformed by the callback function.
     *
     * @example
     * ```
     * const newWorkingMemory = workingMemory.map((memory, index) => {
     *   // Transform the memory here
     *   return transformedMemory;
     * });
     * ```
     */
    map(callback: (memory: Memory, i?: number) => InputMemory): WorkingMemory;
    /**
     * Applies a provided asynchronous function to each memory in the WorkingMemory instance, producing a new WorkingMemory instance.
     * This method is similar to the `map` method but allows for asynchronous transformations of each memory. It returns
     * a new immutable WorkingMemory instance containing the transformed memories, rather than an array of the transformed items.
     *
     * @param callback - An asynchronous function that accepts a memory and optional index (number). The asyncMap method calls the callback function one time for each memory in the WorkingMemory.
     *                   This function should return a Promise that resolves to the transformed memory.
     * @returns A Promise that resolves to a new WorkingMemory instance with each memory transformed by the asynchronous callback function.
     *
     * @example
     * ```
     * const newWorkingMemory = await workingMemory.asyncMap(async (memory, index) => {
     *   // Asynchronously transform the memory here
     *   return await transformMemoryAsync(memory);
     * });
     * ```
     */
    asyncMap(callback: (memory: Memory, i?: number) => Promise<InputMemory>): Promise<WorkingMemory>;
    /**
     * Returns a new WorkingMemory object with the memories sliced from `start` to `end` (`end` not included)
     * where `start` and `end` represent the index of items in the WorkingMemory's internal memory array. It behaves similarly to the `slice()` method of JavaScript arrays.
     *
     * @param start - Zero-based index at which to start extraction. A negative index can be used, indicating an offset from the end of the sequence.
     * @param end - Zero-based index before which to end extraction. `slice` extracts up to but not including `end`. A negative index can be used, indicating an offset from the end of the sequence.
     * @returns A new WorkingMemory instance containing the extracted memories.
     *
     * @example
     * ```
     * const slicedWorkingMemory = workingMemory.slice(1, 3);
     * ```
     */
    slice(start: number, end?: number): WorkingMemory;
    /**
     * Adds a single memory to the current set of memories in the WorkingMemory instance, producing a new WorkingMemory instance.
     *
     * @param memory - The memory to add to the WorkingMemory.
     * @returns A new WorkingMemory instance with the added memory.
     *
     * @example
     * ```
     * const newMemory = { role: ChatMessageRoleEnum.User, content: "Hello, world!" };
     * const newWorkingMemory = workingMemory.withMemory(newMemory);
     * ```
     */
    withMemory(memory: InputMemory): WorkingMemory;
    /**
     * Filters the memories in the WorkingMemory instance using the provided callback, similar to Array.prototype.filter.
     * This method creates a new WorkingMemory instance with all memories that pass the test implemented by the provided function.
     *
     * @param callback - A function that accepts a memory and returns a boolean. If it returns true, the memory is included in the new WorkingMemory instance.
     * @returns A new WorkingMemory instance with the filtered memories.
     */
    filter(callback: (memory: Memory, i?: number) => boolean): WorkingMemory;
    /**
     * Tests whether at least one memory in the WorkingMemory instance passes the test implemented by the provided callback, similar to Array.prototype.some.
     * This method does not modify the WorkingMemory instance.
     *
     * @param callback - A function that accepts a memory and returns a boolean.
     * @returns A boolean indicating whether at least one memory passes the test.
     */
    some(callback: (memory: Memory) => boolean): boolean;
    /**
     * Finds the first memory in the WorkingMemory instance that satisfies the provided testing function, similar to Array.prototype.find.
     *
     * @param callback - A function that accepts a memory and returns a boolean. If it returns true, the memory is returned from the method.
     * @returns The first memory that satisfies the provided testing function, or undefined if no such memory is found.
     */
    find(callback: (memory: Memory) => boolean): {
        role: ChatMessageRoleEnum;
        content: ChatMessageContent_2;
        name?: string | undefined;
        metadata?: Record<string, unknown> | undefined;
        _id: string;
        _timestamp: number;
    } | undefined;
    /**
     * Concatenates the memories of another WorkingMemory (or an array of Memory objects) to the memories of the current WorkingMemory instance, similar to Array.prototype.concat.
     * This method creates a new WorkingMemory instance with the concatenated memories.
     *
     * @param other - Another WorkingMemory (or an array of Memory innstances) to be concatenate with the current instance.
     * @returns A new WorkingMemory instance with the concatenated memories.
     */
    concat(other: MemoryListOrWorkingMemory): WorkingMemory;
    /**
     * Prepends the memories the memories of another WorkingMemory (or an array of Memory objects) to the memories of the current WorkingMemory instance,
     * This method creates a new WorkingMemory instance with the memories of the other instance followed by the current instance's memories, similar to using WorkingMemory#concat in reverse.
     *
     * @param otherWorkingMemory - Another MemoryListOrWorkingMemory instance whose memories are to be prepended to the current instance.
     * @returns A new WorkingMemory instance with the prepended memories.
     */
    prepend(otherWorkingMemory: MemoryListOrWorkingMemory): WorkingMemory;
    /**
     * Adds a monologue memory with the role of Assistant and the provided content to the WorkingMemory instance.
     * This method creates a new WorkingMemory instance with the added monologue memory.
     *
     * @param content - The content of the monologue memory to add.
     * @returns A new WorkingMemory instance with the added monologue memory.
     */
    withMonologue(content: string): WorkingMemory;
    /**
     * Transforms the WorkingMemory using a specified processor and returns a new WorkingMemory instance along with the results of the transformation.
     * This function is a low-level API that is rarely used directly by users. Instead, users typically interact with CognitiveSteps defined in ./cognitiveStep.
     * The transformation can operate in two modes, determined by the `stream` option in the `opts` parameter:
     * - If `stream: true` is passed, the function returns a stream of transformed data.
     * - Otherwise, it returns a single transformed result.
     *
     * @param transformation - The transformation options to apply, including the processor to use.
     * @param opts - Options for the transformation, including whether to use streaming.
     * @returns A Promise resolving to a new WorkingMemory instance and the results of the transformation. The nature of the results depends on the `stream` option.
     */
    transform<SchemaType, PostProcessType>(transformation: MemoryTransformationOptions<SchemaType, PostProcessType>, opts: {
        stream: true;
    } & TransformOptions): Promise<TransformReturnStreaming<PostProcessType>>;
    transform<SchemaType, PostProcessType>(transformation: MemoryTransformationOptions<SchemaType, PostProcessType>, opts?: Omit<TransformOptions, 'stream'>): Promise<TransformReturnNonStreaming<PostProcessType>>;
    transform<SchemaType, PostProcessType>(transformation: MemoryTransformationOptions<SchemaType, PostProcessType>, opts?: {
        stream: false;
    } & Omit<TransformOptions, 'stream'>): Promise<TransformReturnNonStreaming<PostProcessType>>;
    /**
     * Returns a string representation of the internal memories of the WorkingMemory instance.
     * This method formats the internal memories into a readable string, showcasing each memory in a JSON stringified format.
     *
     * @returns A string that represents the internal memories of the WorkingMemory instance.
     */
    toString(): string;
    protected markPending(): void;
    protected resolvePending(): void;
    protected doTransform<SchemaType, PostProcessType>(transformation: MemoryTransformationOptions<SchemaType, PostProcessType>, opts: TransformOptions): Promise<(AsyncIterable<string> | this | Promise<unknown>)[] | (this | SchemaType | PostProcessType)[]>;
    private memoriesFromInputMemories;
    private normalizeMemoryListOrWorkingMemory;
}

export declare interface WorkingMemoryInitOptions {
    soulName: string;
    memories?: InputMemory[];
    processor?: ProcessorSpecification;
    postCloneTransformation?: (workingMemory: WorkingMemory) => WorkingMemory;
}

export { z }

export { }
