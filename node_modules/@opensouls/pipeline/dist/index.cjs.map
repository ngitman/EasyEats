{
  "version": 3,
  "sources": ["../src/index.ts", "../src/filePipeline.ts"],
  "sourcesContent": ["export * from \"./filePipeline.js\"", "import { glob } from \"glob\"\nimport { join, relative } from \"node:path\"\n\nexport interface CallbackParams {\n  \n  /**\n   * A function that returns a promise resolving to the string contents of the file.\n   */\n  content: () => Promise<string>\n  /**\n   * A function that returns a promise resolving to the byte contents of the file.\n   */\n  contentBytes: () => Promise<Buffer>\n  \n  /**\n   * The relative path of the file from the source directory.\n   */\n  path: string\n}\n\nexport type ProcessCallbackReturn = { content: string, key?: string }[] | string[] | string\n\n/**\n * Transforms a given file path into a flat filename representation.\n * This function replaces path separators (both forward slash `/` and backslash `\\`)\n * with double underscores `__` and then replaces any characters that are not\n * alphanumeric, underscores, or periods with a dash `-`.\n * \n * @param {string} path - The original file path to transform.\n * @return {string} The transformed flat filename.\n */\n\nexport const filePathToKey = (path: string) => {\n  return path.replace(/[\\\\\\/]/g, \"__\").replace(/[^\\w\\d_\\.]/g, \"-\")\n}\n\nconst normalizeProcessCallbackReturn = (relativePath: string, result: ProcessCallbackReturn): { content: string, key: string }[] => {\n  if (typeof result === \"string\") {\n    return [{ content: result, key: filePathToKey(relativePath) }]\n  }\n\n  return result.map((item, index) => {\n    if (typeof item === \"string\") {\n      return { content: item, key: filePathToKey(relativePath) + \"_\" + index }\n    }\n    return { content: item.content, key: item.key ?? filePathToKey(relativePath) + \"_\" + index }\n  })\n}\n\nexport interface FilePipelineOpts {\n  /**\n   * `replace`: Removes all files in the destination directory before running the pipeline.\n   * This action ensures the destination directory only contains the output from the current pipeline execution.\n   */\n  replace?: boolean\n}\n\nexport class FilePipeline {\n\n  constructor(public src: string, public dest: string, public opts: FilePipelineOpts = {}) {}\n\n  /**\n   * Processes each file in the source directory, applying a provided callback function to transform the file content.\n   * Each file is read and provided to the callback in two forms: as a UTF-8 string and as raw bytes.\n   * The callback can return either a string, an array of strings, or an array of objects containing the content and an optional key.\n   * If a key is not provided, a default key is generated based on the file's relative path and an index (if needed).\n   * The transformed content is then written to the destination directory under the generated or provided key.\n   * \n   * @param callback - A function that takes a `CallbackParams` object and returns a `ProcessCallbackReturn`.\n   *                   This function is expected to perform the necessary transformations on the file content.\n   * @returns - A promise that resolves when all files have been processed.\n   */\n  async process(callback: (params: CallbackParams) => Promise<ProcessCallbackReturn>) {\n    const { mkdir, readFile, writeFile, stat } = await import(\"node:fs/promises\")\n    const { emptyDir } = await import(\"fs-extra/esm\")\n\n    let globSrc = join(this.src, \"**/*\")\n\n    if (this.opts.replace) {\n      await emptyDir(this.dest) // emptyDir also creates the dir\n    } else {\n      await mkdir(this.dest, { recursive: true })\n    }\n\n    const files = await glob(globSrc, { absolute: true })\n\n    for (const filePath of files) {\n      if ((await stat(filePath)).isDirectory()) {\n        continue\n      }\n      const relativeToSrc = relative(this.src, filePath)\n      console.log(`processing ${relativeToSrc}`)\n      const content = () => {\n        return readFile(filePath, \"utf8\")\n      }\n\n      const contentBytes = () => {\n        return readFile(filePath)\n      }\n\n      const result = await callback({\n        content,\n        contentBytes,\n        path: relativeToSrc\n      })\n\n      const normalizedResult = normalizeProcessCallbackReturn(relativeToSrc, result)\n\n      for (const { content, key } of normalizedResult) {\n        const destPath = join(this.dest, key)\n        console.log(`writing ${destPath}`)\n        // write\n        await writeFile(destPath, content)\n      }\n\n    }\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,kBAAqB;AACrB,uBAA+B;AA+BxB,IAAM,gBAAgB,CAAC,SAAiB;AAC7C,SAAO,KAAK,QAAQ,WAAW,IAAI,EAAE,QAAQ,eAAe,GAAG;AACjE;AAEA,IAAM,iCAAiC,CAAC,cAAsB,WAAsE;AAClI,MAAI,OAAO,WAAW,UAAU;AAC9B,WAAO,CAAC,EAAE,SAAS,QAAQ,KAAK,cAAc,YAAY,EAAE,CAAC;AAAA,EAC/D;AAEA,SAAO,OAAO,IAAI,CAAC,MAAM,UAAU;AACjC,QAAI,OAAO,SAAS,UAAU;AAC5B,aAAO,EAAE,SAAS,MAAM,KAAK,cAAc,YAAY,IAAI,MAAM,MAAM;AAAA,IACzE;AACA,WAAO,EAAE,SAAS,KAAK,SAAS,KAAK,KAAK,OAAO,cAAc,YAAY,IAAI,MAAM,MAAM;AAAA,EAC7F,CAAC;AACH;AAUO,IAAM,eAAN,MAAmB;AAAA,EAExB,YAAmB,KAAoB,MAAqB,OAAyB,CAAC,GAAG;AAAtE;AAAoB;AAAqB;AAAA,EAA8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAa1F,MAAM,QAAQ,UAAsE;AAClF,UAAM,EAAE,OAAO,UAAU,WAAW,KAAK,IAAI,MAAM,OAAO,kBAAkB;AAC5E,UAAM,EAAE,SAAS,IAAI,MAAM,OAAO,cAAc;AAEhD,QAAI,cAAU,uBAAK,KAAK,KAAK,MAAM;AAEnC,QAAI,KAAK,KAAK,SAAS;AACrB,YAAM,SAAS,KAAK,IAAI;AAAA,IAC1B,OAAO;AACL,YAAM,MAAM,KAAK,MAAM,EAAE,WAAW,KAAK,CAAC;AAAA,IAC5C;AAEA,UAAM,QAAQ,UAAM,kBAAK,SAAS,EAAE,UAAU,KAAK,CAAC;AAEpD,eAAW,YAAY,OAAO;AAC5B,WAAK,MAAM,KAAK,QAAQ,GAAG,YAAY,GAAG;AACxC;AAAA,MACF;AACA,YAAM,oBAAgB,2BAAS,KAAK,KAAK,QAAQ;AACjD,cAAQ,IAAI,cAAc,aAAa,EAAE;AACzC,YAAM,UAAU,MAAM;AACpB,eAAO,SAAS,UAAU,MAAM;AAAA,MAClC;AAEA,YAAM,eAAe,MAAM;AACzB,eAAO,SAAS,QAAQ;AAAA,MAC1B;AAEA,YAAM,SAAS,MAAM,SAAS;AAAA,QAC5B;AAAA,QACA;AAAA,QACA,MAAM;AAAA,MACR,CAAC;AAED,YAAM,mBAAmB,+BAA+B,eAAe,MAAM;AAE7E,iBAAW,EAAE,SAAAA,UAAS,IAAI,KAAK,kBAAkB;AAC/C,cAAM,eAAW,uBAAK,KAAK,MAAM,GAAG;AACpC,gBAAQ,IAAI,WAAW,QAAQ,EAAE;AAEjC,cAAM,UAAU,UAAUA,QAAO;AAAA,MACnC;AAAA,IAEF;AAAA,EACF;AACF;",
  "names": ["content"]
}
