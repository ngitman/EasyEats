{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["/* eslint-disable arrow-body-style */\nimport { InternalPerception, WorkingMemory } from '@opensouls/core';\nimport { DeveloperInteractionRequest, Json, Perception } from '@opensouls/core';\nimport { MentalProcess } from './mentalProcess.js'\n\nexport * from \"./mentalProcess.js\"\nexport * from \"@opensouls/core\"\nexport * from \"@opensouls/soul\"\n\nexport const ALLOWED_RAG_FILE_EXTENSIONS = [\n  \".js\",\n  \".ts\",\n  \".mdx\",\n  \".md\",\n  \".txt\",\n  \".json\",\n  \".yml\",\n  \".xml\",\n  \".html\",\n  \".tsx\",\n  \".jsx\",\n  \".py\",\n]\n\nexport interface CognitiveEventBase {\n  process: MentalProcess<any>\n  perception: Omit<InternalPerception, \"_id\" | \"_kind\" | \"_pending\" | \"_timestamp\" | \"internal\">\n  params?: Json\n}\n\nexport interface CognitiveEventAbsolute extends CognitiveEventBase {\n  when: Date\n}\n\nexport interface CognitiveEventOffset extends CognitiveEventBase {\n  in: number // seconds from now\n}\n\nexport type CognitiveEvent = CognitiveEventAbsolute | CognitiveEventOffset\n\n\nexport interface DefaultActions {\n  /*\n    * expire will end the current Soul and the soul will stop processing perceptions\n    */\n  expire: () => void\n  log: (...args: any) => void\n  speak: (message: AsyncIterable<string>|string) => void\n  scheduleEvent: (evt: CognitiveEvent) => void\n  dispatch: (evt: DeveloperInteractionRequest) => void\n}\n\n/* begin vectordb */\n\nexport type VectorMetadata = Record<string, Json>\n\nexport interface VectorRecord {\n  key: string\n  content: Json\n  metadata: VectorMetadata\n  embedding?: Embedding\n}\n\nexport interface VectorRecordWithDistance extends VectorRecord {\n  distance: number\n  similarity: number\n}\n\n/**\n * @deprecated use VectorRecordWithDistance instead\n */\nexport type VectorRecordWithSimilarity = VectorRecordWithDistance\n\n/* end vectordb */\n\nexport interface RagIngestionBody {\n  rootKey: string\n  content: string // base64 encoded binary data\n  contentType?: string\n  maxTokens?: number\n  metadata?: VectorMetadata\n}\n\nexport interface WithRagContextOpts {\n  // currently no opts\n}\n\nexport interface SoulStoreGetOpts {\n  includeMetadata?: boolean\n}\n\nexport type Embedding = number[]\n\nexport type PerceptionProcessorReturnTypes<PropType = any> = undefined | [WorkingMemory] | [WorkingMemory, MentalProcess<PropType>] | [WorkingMemory, MentalProcess<PropType>, PropType]\n\nexport type PerceptionProcessor = <PropType>(perceptionArgs: {\n  perception: Perception,\n  currentProcess: MentalProcess<any>,\n  workingMemory: WorkingMemory,\n}) => Promise<PerceptionProcessorReturnTypes<PropType>>\n\nexport interface RagConfigfile {\n  bucket: string\n}\n\nexport interface SoulConfig {\n  soul: string,\n  path?: string,\n  paths?: string[],\n}\n\nexport interface RagSearchOpts {\n  query: Embedding | string\n  limit?: number\n  maxDistance?: number\n  bucketName?: string\n}\n\nexport interface VectorStorSearchOpts {\n  filter?: VectorMetadata\n  resultLimit?: number\n  maxDistance?: number\n  minSimilarity?: number\n  model?: string\n}\n\nexport interface VectorStoreHook {\n  createEmbedding: (content: string, model?: string) => Promise<Embedding>\n  delete: (key: string) => void\n  fetch: <T = unknown>(key: string, opts?: SoulStoreGetOpts) => Promise<(typeof opts extends { includeMetadata: true } ? VectorRecord : T) | undefined>\n  search: (query: Embedding | string, opts?: VectorStorSearchOpts) => Promise<VectorRecordWithDistance[]>\n  set: (key: string, value: Json, metadata?: VectorMetadata, model?: string) => void\n}\n\nexport interface SoulVectorStoreHook extends Omit<VectorStoreHook, \"get\"> {\n  /**\n   * @deprecated use fetch instead\n   */\n  get: <T = unknown>(key: string, opts?: SoulStoreGetOpts) => (typeof opts extends { includeMetadata: true } ? VectorRecord : T) | undefined\n}\n\n/**\n * note to open souls devs. If you change this, you need to change engine code\n * to adjust the bundle.\n */\nexport interface SoulHooks {\n  useActions: () => DefaultActions\n  useProcessManager: () => {\n    invocationCount: number\n    /**\n     * @deprecated use the return from a MentalProcess instead.\n     */\n    setNextProcess: <PropType>(process: MentalProcess<PropType>, props?: PropType) => void\n    wait: (ms: number) => Promise<void>\n    previousMentalProcess?: MentalProcess<any>\n  }\n  usePerceptions: () => {\n    invokingPerception: Perception | null | undefined,\n    pendingPerceptions: {\n      current: Perception[],\n    },\n  },\n  useProcessMemory: <T = null>(initialValue: T) => { current: T }\n  useSoulStore: () => SoulVectorStoreHook,\n  useBlueprintStore: (bucketName?: string) => VectorStoreHook,\n  useOrganizationStore: (bucketName?: string) => VectorStoreHook,\n  useSoulMemory: <T = null>(name: string, initialValue?: T) => { current: T }\n  useRag(bucketName?: string): {\n    search: (opts: RagSearchOpts) => Promise<VectorRecordWithDistance[]>\n    withRagContext: <T = any>(step: T, opts?: WithRagContextOpts) => Promise<T>\n  }\n  useTool<ParamType = Json | void, ResponseType = Json>(name: string): (params?: ParamType) => Promise<ResponseType>\n}\n\nexport const defaultRagBucketName = (blueprint: string) => {\n  return `__blueprint-rag-${blueprint}`\n}\n\n// The ENGINE passes in these global hooks to the soul.\n\nconst getHooks = () => {\n  if (!(globalThis as any).soul) {\n    console.error(\"oops, no hooks\", (globalThis as any).soul)\n  }\n\n  return (globalThis as any).soul.__hooks as SoulHooks | undefined\n}\n\nexport const useActions: SoulHooks[\"useActions\"] = () => {\n  const hooks = getHooks()\n  if (!hooks) throw new Error(\"useActions called when no hooks are available. Are you executing this code on the SOUL ENGINE?\")\n  return hooks.useActions()\n}\n\nexport const useProcessManager: SoulHooks[\"useProcessManager\"] = () => {\n  const hooks = getHooks()\n  if (!hooks) throw new Error(\"useActions called when no hooks are available. Are you executing this code on the SOUL ENGINE?\")\n  return hooks.useProcessManager()\n}\n\nexport const usePerceptions: SoulHooks[\"usePerceptions\"] = () => {\n  const hooks = getHooks()\n  if (!hooks) throw new Error(\"usePerceptions called when no hooks are available. Are you executing this code on the SOUL ENGINE?\")\n  return hooks.usePerceptions()\n}\n\nexport const useProcessMemory: SoulHooks[\"useProcessMemory\"] = (initialValue) => {\n  const hooks = getHooks()\n  if (!hooks) throw new Error(\"useProcessMemory called when no hooks are available. Are you executing this code on the SOUL ENGINE?\")\n  return hooks.useProcessMemory(initialValue)\n}\n\nexport const useSoulStore: SoulHooks[\"useSoulStore\"] = () => {\n  const hooks = getHooks()\n  if (!hooks) throw new Error(\"useSoulStore called when no hooks are available. Are you executing this code on the SOUL ENGINE?\")\n  return hooks.useSoulStore()\n}\n\nexport const useBlueprintStore: SoulHooks[\"useBlueprintStore\"] = (bucketName?: string) => {\n  const hooks = getHooks()\n  if (!hooks) throw new Error(\"useBlueprintStore called when no hooks are available. Are you executing this code on the SOUL ENGINE?\")\n  return hooks.useBlueprintStore(bucketName)\n}\n\nexport const useOrganizationStore: SoulHooks[\"useOrganizationStore\"] = (bucketName?: string) => {\n  const hooks = getHooks()\n  if (!hooks) throw new Error(\"useOrganizationStore called when no hooks are available. Are you executing this code on the SOUL ENGINE?\")\n  return hooks.useOrganizationStore(bucketName)\n}\n\nexport const useSoulMemory: SoulHooks[\"useSoulMemory\"] = (name, initialValue) => {\n  const hooks = getHooks()\n  if (!hooks) throw new Error(\"useSoulMemory called when no hooks are available. Are you executing this code on the SOUL ENGINE?\")\n  return hooks.useSoulMemory(name, initialValue)\n}\n\nexport const useRag = (bucketName?: string) => {\n  const hooks = getHooks()\n  if (!hooks) throw new Error(\"useRag called when no hooks are available. Are you executing this code on the SOUL ENGINE?\")\n  return hooks.useRag(bucketName)\n}\n\nexport const useTool = <ParamType = Json, ResponseType = Json>(toolName: string) => {\n  const hooks = getHooks()\n  if (!hooks) throw new Error(\"useTool called when no hooks are available. Are you executing this code on the SOUL ENGINE?\")\n  return hooks.useTool<ParamType, ResponseType>(toolName)\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,wBAAc,4BANd;AAOA,wBAAc,4BAPd;AASO,IAAM,8BAA8B;AAAA,EACzC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAwJO,IAAM,uBAAuB,CAAC,cAAsB;AACzD,SAAO,mBAAmB,SAAS;AACrC;AAIA,IAAM,WAAW,MAAM;AACrB,MAAI,CAAE,WAAmB,MAAM;AAC7B,YAAQ,MAAM,kBAAmB,WAAmB,IAAI;AAAA,EAC1D;AAEA,SAAQ,WAAmB,KAAK;AAClC;AAEO,IAAM,aAAsC,MAAM;AACvD,QAAM,QAAQ,SAAS;AACvB,MAAI,CAAC;AAAO,UAAM,IAAI,MAAM,gGAAgG;AAC5H,SAAO,MAAM,WAAW;AAC1B;AAEO,IAAM,oBAAoD,MAAM;AACrE,QAAM,QAAQ,SAAS;AACvB,MAAI,CAAC;AAAO,UAAM,IAAI,MAAM,gGAAgG;AAC5H,SAAO,MAAM,kBAAkB;AACjC;AAEO,IAAM,iBAA8C,MAAM;AAC/D,QAAM,QAAQ,SAAS;AACvB,MAAI,CAAC;AAAO,UAAM,IAAI,MAAM,oGAAoG;AAChI,SAAO,MAAM,eAAe;AAC9B;AAEO,IAAM,mBAAkD,CAAC,iBAAiB;AAC/E,QAAM,QAAQ,SAAS;AACvB,MAAI,CAAC;AAAO,UAAM,IAAI,MAAM,sGAAsG;AAClI,SAAO,MAAM,iBAAiB,YAAY;AAC5C;AAEO,IAAM,eAA0C,MAAM;AAC3D,QAAM,QAAQ,SAAS;AACvB,MAAI,CAAC;AAAO,UAAM,IAAI,MAAM,kGAAkG;AAC9H,SAAO,MAAM,aAAa;AAC5B;AAEO,IAAM,oBAAoD,CAAC,eAAwB;AACxF,QAAM,QAAQ,SAAS;AACvB,MAAI,CAAC;AAAO,UAAM,IAAI,MAAM,uGAAuG;AACnI,SAAO,MAAM,kBAAkB,UAAU;AAC3C;AAEO,IAAM,uBAA0D,CAAC,eAAwB;AAC9F,QAAM,QAAQ,SAAS;AACvB,MAAI,CAAC;AAAO,UAAM,IAAI,MAAM,0GAA0G;AACtI,SAAO,MAAM,qBAAqB,UAAU;AAC9C;AAEO,IAAM,gBAA4C,CAAC,MAAM,iBAAiB;AAC/E,QAAM,QAAQ,SAAS;AACvB,MAAI,CAAC;AAAO,UAAM,IAAI,MAAM,mGAAmG;AAC/H,SAAO,MAAM,cAAc,MAAM,YAAY;AAC/C;AAEO,IAAM,SAAS,CAAC,eAAwB;AAC7C,QAAM,QAAQ,SAAS;AACvB,MAAI,CAAC;AAAO,UAAM,IAAI,MAAM,4FAA4F;AACxH,SAAO,MAAM,OAAO,UAAU;AAChC;AAEO,IAAM,UAAU,CAAwC,aAAqB;AAClF,QAAM,QAAQ,SAAS;AACvB,MAAI,CAAC;AAAO,UAAM,IAAI,MAAM,6FAA6F;AACzH,SAAO,MAAM,QAAiC,QAAQ;AACxD;",
  "names": []
}
