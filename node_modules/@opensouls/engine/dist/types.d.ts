import { DeveloperInteractionRequest } from '@opensouls/core';
import { InternalPerception } from '@opensouls/core';
import { Json } from '@opensouls/core';
import { Perception } from '@opensouls/core';
import { WorkingMemory } from '@opensouls/core';

export declare const ALLOWED_RAG_FILE_EXTENSIONS: string[];

export declare type CognitiveEvent = CognitiveEventAbsolute | CognitiveEventOffset;

export declare interface CognitiveEventAbsolute extends CognitiveEventBase {
    when: Date;
}

export declare interface CognitiveEventBase {
    process: MentalProcess<any>;
    perception: Omit<InternalPerception, "_id" | "_kind" | "_pending" | "_timestamp" | "internal">;
    params?: Json;
}

export declare interface CognitiveEventOffset extends CognitiveEventBase {
    in: number;
}

export declare interface DefaultActions {
    expire: () => void;
    log: (...args: any) => void;
    speak: (message: AsyncIterable<string> | string) => void;
    scheduleEvent: (evt: CognitiveEvent) => void;
    dispatch: (evt: DeveloperInteractionRequest) => void;
}

export declare const defaultRagBucketName: (blueprint: string) => string;

export declare type Embedding = number[];

export declare type MentalProcess<ParamType = Record<number | string, any>, CortexStepType = any> = (args: MentalProcessArguments<ParamType, CortexStepType>) => Promise<MentalProcessReturnTypes<CortexStepType, ParamType>>;

export declare interface MentalProcessArguments<ParamType, CortexStepType = any> {
    params: ParamType;
    step: CortexStepType;
    workingMemory: WorkingMemory;
}

export declare interface MentalProcessReturnOptions<ParamType> {
    params?: ParamType;
    executeNow?: boolean;
}

export declare type MentalProcessReturnTypes<CortexStepType, ParamType = any> = CortexStepType | WorkingMemory | [WorkingMemory, MentalProcess<ParamType>] | [WorkingMemory, MentalProcess<ParamType>, MentalProcessReturnOptions<ParamType>];

export declare type PerceptionProcessor = <PropType>(perceptionArgs: {
    perception: Perception;
    currentProcess: MentalProcess<any>;
    workingMemory: WorkingMemory;
}) => Promise<PerceptionProcessorReturnTypes<PropType>>;

export declare type PerceptionProcessorReturnTypes<PropType = any> = undefined | [WorkingMemory] | [WorkingMemory, MentalProcess<PropType>] | [WorkingMemory, MentalProcess<PropType>, PropType];

export declare interface RagConfigfile {
    bucket: string;
}

export declare interface RagIngestionBody {
    rootKey: string;
    content: string;
    contentType?: string;
    maxTokens?: number;
    metadata?: VectorMetadata;
}

export declare interface RagSearchOpts {
    query: Embedding | string;
    limit?: number;
    maxDistance?: number;
    bucketName?: string;
}

export declare interface SoulConfig {
    soul: string;
    path?: string;
    paths?: string[];
}

/**
 * note to open souls devs. If you change this, you need to change engine code
 * to adjust the bundle.
 */
export declare interface SoulHooks {
    useActions: () => DefaultActions;
    useProcessManager: () => {
        invocationCount: number;
        /**
         * @deprecated use the return from a MentalProcess instead.
         */
        setNextProcess: <PropType>(process: MentalProcess<PropType>, props?: PropType) => void;
        wait: (ms: number) => Promise<void>;
        previousMentalProcess?: MentalProcess<any>;
    };
    usePerceptions: () => {
        invokingPerception: Perception | null | undefined;
        pendingPerceptions: {
            current: Perception[];
        };
    };
    useProcessMemory: <T = null>(initialValue: T) => {
        current: T;
    };
    useSoulStore: () => SoulVectorStoreHook;
    useBlueprintStore: (bucketName?: string) => VectorStoreHook;
    useOrganizationStore: (bucketName?: string) => VectorStoreHook;
    useSoulMemory: <T = null>(name: string, initialValue?: T) => {
        current: T;
    };
    useRag(bucketName?: string): {
        search: (opts: RagSearchOpts) => Promise<VectorRecordWithDistance[]>;
        withRagContext: <T = any>(step: T, opts?: WithRagContextOpts) => Promise<T>;
    };
    useTool<ParamType = Json | void, ResponseType = Json>(name: string): (params?: ParamType) => Promise<ResponseType>;
}

export declare interface SoulStoreGetOpts {
    includeMetadata?: boolean;
}

export declare interface SoulVectorStoreHook extends Omit<VectorStoreHook, "get"> {
    /**
     * @deprecated use fetch instead
     */
    get: <T = unknown>(key: string, opts?: SoulStoreGetOpts) => (typeof opts extends {
        includeMetadata: true;
    } ? VectorRecord : T) | undefined;
}

export declare const useActions: SoulHooks["useActions"];

export declare const useBlueprintStore: SoulHooks["useBlueprintStore"];

export declare const useOrganizationStore: SoulHooks["useOrganizationStore"];

export declare const usePerceptions: SoulHooks["usePerceptions"];

export declare const useProcessManager: SoulHooks["useProcessManager"];

export declare const useProcessMemory: SoulHooks["useProcessMemory"];

export declare const useRag: (bucketName?: string) => {
    search: (opts: RagSearchOpts) => Promise<VectorRecordWithDistance[]>;
    withRagContext: <T = any>(step: T, opts?: WithRagContextOpts) => Promise<T>;
};

export declare const useSoulMemory: SoulHooks["useSoulMemory"];

export declare const useSoulStore: SoulHooks["useSoulStore"];

export declare const useTool: <ParamType = Json, ResponseType = Json>(toolName: string) => (params?: ParamType | undefined) => Promise<ResponseType>;

export declare type VectorMetadata = Record<string, Json>;

export declare interface VectorRecord {
    key: string;
    content: Json;
    metadata: VectorMetadata;
    embedding?: Embedding;
}

export declare interface VectorRecordWithDistance extends VectorRecord {
    distance: number;
    similarity: number;
}

/**
 * @deprecated use VectorRecordWithDistance instead
 */
export declare type VectorRecordWithSimilarity = VectorRecordWithDistance;

export declare interface VectorStoreHook {
    createEmbedding: (content: string, model?: string) => Promise<Embedding>;
    delete: (key: string) => void;
    fetch: <T = unknown>(key: string, opts?: SoulStoreGetOpts) => Promise<(typeof opts extends {
        includeMetadata: true;
    } ? VectorRecord : T) | undefined>;
    search: (query: Embedding | string, opts?: VectorStorSearchOpts) => Promise<VectorRecordWithDistance[]>;
    set: (key: string, value: Json, metadata?: VectorMetadata, model?: string) => void;
}

export declare interface VectorStorSearchOpts {
    filter?: VectorMetadata;
    resultLimit?: number;
    maxDistance?: number;
    minSimilarity?: number;
    model?: string;
}

export declare interface WithRagContextOpts {
}


export * from "@opensouls/core";
export * from "@opensouls/soul";

export { }
// compilation note: this file is included manually at the end of the types.d.ts in the dist folder
// see https://github.com/microsoft/rushstack/issues/1709

// these are added to the global scope when executing in the SOUL ENGINE
// $$ is a convenience method using Mustache to access the soul.env variables.
declare global {
  const soul: {
    __hooks: SoulHooks
    env: Record<string, Json>,
  }
  const $$: (template: string) => string
}
