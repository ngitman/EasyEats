{"version":3,"file":"reactive.js","sources":["../src/observer.ts","../src/reaction.ts","../src/action.ts","../src/untracked.ts","../src/reporting.ts","../src/observable.ts","../src/autorun.ts","../src/atom.ts"],"sourcesContent":["import { $reactive, InternalObservable, ObserverConnection, ObserverConnectionSource } from \"./observable\";\n\nexport class Observer {\n  public observing = new Map<\n    InternalObservable<object>,\n    {\n      iterate: false | true;\n      byKey: Set<string | number>;\n    }\n  >();\n\n  constructor(public readonly trigger: () => void) {}\n\n  public registerConnection<T extends object>(source: ObserverConnectionSource<T>) {\n    let existing = this.observing.get(source.observable);\n    if (!existing) {\n      existing = {\n        byKey: new Set(),\n        iterate: false,\n      };\n      this.observing.set(source.observable, existing);\n    }\n    if (source.type === \"iterate\") {\n      existing.iterate = true;\n    } else {\n      existing.byKey.add(source.key);\n    }\n  }\n\n  public removeObservers() {\n    this.observing.forEach((val, key) => {\n      if (val.iterate) {\n        key[$reactive].connections.iterate.delete(this);\n      }\n      val.byKey.forEach((subkey) => {\n        key[$reactive].connections.byKey.get(subkey).delete(this);\n      });\n    });\n    this.observing.clear();\n  }\n}\n","import { Observer } from \"./observer\";\n\nlet runningReactions: Reaction[] = [];\nexport class Reaction extends Observer {\n  private isInitial = true;\n\n  constructor(\n    private func: () => void | Promise<void>,\n    private options: { fireImmediately: boolean; name: string },\n    private effect?: () => void | Promise<void>\n  ) {\n    super(() => this._trigger());\n\n    if (!effect && !this.options.fireImmediately) {\n      throw new Error(\"if no effect function passed, should always fireImmediately\");\n    }\n    // fire reaction\n    this.reaction();\n  }\n\n  private reaction = () => {\n    runningReactions.push(this);\n\n    try {\n      this.func();\n    } finally {\n      runningReactions.pop();\n    }\n\n    if (this.effect && (!this.isInitial || this.options.fireImmediately)) {\n      this.effect();\n    }\n    this.isInitial = false;\n  };\n\n  private _trigger() {\n    // TODO: catch errors\n    if (runningReactions.includes(this)) {\n      throw new Error(\"already running reaction\");\n    }\n    this.removeObservers();\n    this.reaction();\n  }\n}\n\nexport function hasRunningReaction() {\n  return !!runningReactions.length;\n}\n\nexport function runningReaction() {\n  return runningReactions.length ? runningReactions[runningReactions.length - 1] : undefined;\n}\n\nexport function reaction(\n  func: () => any | Promise<any>,\n  effect: () => void | Promise<void>,\n  options?: { fireImmediately?: boolean; name?: string }\n) {\n  const newOptions = { name: \"unnamed\", fireImmediately: true, ...options };\n  const r = new Reaction(func, newOptions, effect);\n  return r;\n}\n","import { clearBatch } from \"./reporting\";\n\nlet runningActionCount = 0;\n\nexport function isActionRunning() {\n  return runningActionCount > 0;\n}\n\nexport function runInAction<T>(func: () => T) {\n  runningActionCount++;\n  try {\n    return func();\n  } finally {\n    runningActionCount--;\n\n    if (runningActionCount === 0) {\n      clearBatch();\n    }\n  }\n}\n","let disableTracking = false;\n\nexport function isTrackingDisabled() {\n  return disableTracking;\n}\n\nexport function untracked(fn: () => void) {\n  disableTracking = true;\n  try {\n    fn();\n  } finally {\n    disableTracking = false;\n  }\n}\n\nexport function untrackedCB(fn: () => void) {\n  return () => untracked(fn);\n}\n","import { isActionRunning } from \"./action\";\nimport { $reactive, ObserverConnectionSource, Operation } from \"./observable\";\nimport { Observer } from \"./observer\";\nimport { runningReaction } from \"./reaction\";\nimport { isTrackingDisabled } from \"./untracked\";\n\nlet batch: Operation<any>[] = [];\n\nexport function clearBatch<T>() {\n  const copy = [...batch];\n  batch = [];\n  reportChangedArray(copy);\n}\n\nfunction reportChangedArray<T>(operations: Array<Operation<T>>) {\n  // create a copy because\n  // 1. the set observable[$reactive].connections will be changed while executing reactions (connections will be added / removed)\n  // 2. de-duplicate reactions (only run reactions once, for example if it's subscribed to both 'get' and 'iterate')\n  const toRun = new Set<Observer>();\n\n  operations.forEach((operation) => {\n    if (operation.type === \"add\" || operation.type === \"delete\") {\n      operation.observable[$reactive].connections.iterate.forEach((connection) => {\n        toRun.add(connection);\n      });\n    }\n    operation.observable[$reactive].connections.byKey.get(operation.key)?.forEach((connection) => {\n      toRun.add(connection);\n    });\n  });\n\n  toRun.forEach((observer) => {\n    observer.trigger();\n  });\n}\n\nexport function reportChanged<T>(operation: Operation<T>) {\n  if (isActionRunning()) {\n    batch.push(operation);\n    return;\n  }\n  reportChangedArray([operation]);\n}\n\nfunction addConnection<T>(source: ObserverConnectionSource<T>, observer: Observer) {\n  if (source.type === \"iterate\") {\n    source.observable[$reactive].connections.iterate.add(observer);\n  } else {\n    let set = source.observable[$reactive].connections.byKey.get(source.key);\n    if (!set) {\n      set = new Set<Observer>();\n      source.observable[$reactive].connections.byKey.set(source.key, set);\n    }\n    set.add(observer);\n  }\n}\n\nexport function reportObserved<T extends object>(source: ObserverConnectionSource<T>, implicitObserver: Observer) {\n  if (isTrackingDisabled()) {\n    return;\n  }\n\n  const reaction = runningReaction();\n  if (reaction) {\n    addConnection(source, reaction);\n    reaction.registerConnection(source);\n  }\n\n  if (implicitObserver) {\n    addConnection(source, implicitObserver);\n    implicitObserver.registerConnection(source);\n  }\n}\n","import { runInAction } from \".\";\nimport { Observer } from \"./observer\";\nimport { hasRunningReaction } from \"./reaction\";\nimport { reportChanged, reportObserved } from \"./reporting\";\n\nexport const $skipreactive = Symbol(\"$skipreactive\");\nexport const $reactive = Symbol(\"$reactive\");\nexport const $reactiveproxy = Symbol(\"$reactiveproxy\");\n\ntype Admin<T> = {\n  connections: {\n    iterate: Set<Observer>;\n    byKey: Map<string | number, Set<Observer>>;\n  };\n  proxy: InternalObservable<T>;\n  proxiesWithImplicitObserver: Map<Observer, InternalObservable<T>>;\n  raw: T;\n  shallow: boolean;\n};\nexport type InternalObservable<T> = {\n  [$reactive]: Admin<T>;\n} & T;\n\nexport function isReactive<T>(object: T, implicitObserver?: Observer): object is InternalObservable<T> {\n  return !!(\n    object &&\n    (object as any)[$reactiveproxy] &&\n    (object as any)[$reactiveproxy].implicitObserver === implicitObserver\n  );\n}\n\nexport function markRaw<T>(object: T) {\n  object[$skipreactive] = true;\n  return object;\n}\n\nfunction isInternalObservable<T>(object: T): object is InternalObservable<T> {\n  return !!(object && !isReactive(object) && (object as any)[$reactive]);\n}\n\nexport type ObserverConnectionSource<T> = {\n  observable: InternalObservable<T>;\n} & (\n  | {\n      key: string | number;\n      type: \"has\" | \"get\";\n    }\n  | {\n      type: \"iterate\";\n    }\n);\n\nexport type ObserverConnection<T> = {\n  source: ObserverConnectionSource<T>;\n  observer: Observer;\n};\n\nexport type Operation<T> = {\n  observable: InternalObservable<T>;\n  key: string | number;\n} & (\n  | {\n      value: any;\n      type: \"add\";\n    }\n  | { type: \"update\"; value: any; oldValue: any }\n  | { type: \"delete\"; oldValue: any }\n);\n\nfunction observable<T>(object: T, implicitObserver?: Observer, shallow = false) {\n  if (object[$skipreactive]) {\n    return object;\n  }\n\n  if (isReactive(object, implicitObserver)) {\n    return object;\n  }\n\n  const observable = _observable(object, shallow);\n\n  if (!implicitObserver) {\n    return observable;\n  }\n\n  let proxy = observable[$reactive].proxiesWithImplicitObserver.get(implicitObserver);\n  if (!proxy) {\n    const proxyTraps = {\n      implicitObserver,\n    } as any;\n    Object.setPrototypeOf(proxyTraps, objectProxyTraps);\n    proxy = new Proxy<InternalObservable<T>>(observable[$reactive].raw as any, proxyTraps);\n\n    observable[$reactive].proxiesWithImplicitObserver.set(implicitObserver, proxy);\n  }\n  return proxy;\n}\nexport const reactive = observable;\nfunction _observable<T>(object: T, shallow = false) {\n  if (isReactive(object)) {\n    return object;\n  }\n\n  if (isInternalObservable(object)) {\n    return object[$reactive].proxy;\n  }\n\n  if (object[$reactive] || object[$reactiveproxy]) {\n    throw new Error(\"unexpected\");\n  }\n  const value: Admin<T> = {\n    connections: {\n      iterate: new Set<Observer>(),\n      byKey: new Map<string | number, Set<Observer>>(),\n    },\n    proxy: {} as any, // temp\n    raw: object,\n    proxiesWithImplicitObserver: new Map(),\n    shallow,\n  };\n  Object.defineProperty(object, $reactive, {\n    enumerable: false,\n    writable: true,\n    configurable: true,\n    value,\n  });\n  const proxy = new Proxy<InternalObservable<T>>(object as any as InternalObservable<T>, objectProxyTraps);\n  value.proxy = proxy;\n  return proxy;\n}\n\nconst objectProxyTraps: ProxyHandler<InternalObservable<any>> = {\n  // Read:\n  has(target: InternalObservable<any>, key: PropertyKey): boolean {\n    const result = Reflect.has(target, key);\n\n    if (typeof key === \"symbol\") {\n      return result;\n    }\n\n    // register and save (observable.prop -> runningReaction)\n    reportObserved({ observable: target, key, type: \"has\" }, this.implicitObserver);\n    return result;\n  },\n  get(target: InternalObservable<any>, key: PropertyKey, receiver: any): any {\n    if (key === $reactiveproxy) {\n      // for isObservable\n      return { implicitObserver: this.implicitObserver };\n    }\n\n    const result = Reflect.get(target, key, receiver);\n\n    if (typeof key === \"symbol\") {\n      if (key.toString() === \"Symbol($reactiveproxy)\") {\n        console.error(\n          \"warning, Symbol($reactiveproxy) passed, but does not match $reactiveproxy. Multiple Reactive libraries loaded?\"\n        );\n      }\n      return result;\n    }\n\n    // register and save (observable.prop -> runningReaction)\n    if (key === \"length\" && Array.isArray(target)) {\n      reportObserved({ observable: target as any /* TODO */, type: \"iterate\" }, this.implicitObserver);\n    } else {\n      reportObserved({ observable: target, key, type: \"get\" }, this.implicitObserver);\n    }\n\n    if (isInternalObservable(result)) {\n      // already has an observable. Call observable() again to make sure we get the right proxy for implicitObserver\n      return observable(result, this.implicitObserver);\n    }\n\n    if (target[$reactive].shallow) {\n      return result;\n    }\n    // if we are inside a reaction and observable.prop is an object wrap it in an observable too\n    // this is needed to intercept property access on that object too (dynamic observable tree)\n    // const observableResult = rawToProxy.get(result)\n    if (\n      typeof result === \"object\" &&\n      result !== null &&\n      !isReactive(result, this.implicitObserver) &&\n      !Object.isFrozen(result)\n    ) {\n      // do not violate the none-configurable none-writable prop get handler invariant\n      // fall back to none reactive mode in this case, instead of letting the Proxy throw a TypeError\n      const descriptor = Reflect.getOwnPropertyDescriptor(target, key);\n      if (\n        (!descriptor || !(descriptor.writable === false && descriptor.configurable === false)) &&\n        (hasRunningReaction() || this.implicitObserver)\n      ) {\n        return observable(result, this.implicitObserver);\n      }\n    }\n    // otherwise return the observable wrapper if it is already created and cached or the raw object\n    return result;\n  },\n  ownKeys(target: InternalObservable<any>) {\n    reportObserved({ observable: target, type: \"iterate\" }, this.implicitObserver);\n    return Reflect.ownKeys(target);\n  },\n  // Write:\n  set(target: InternalObservable<any>, key: PropertyKey, value: any, receiver: any): boolean {\n    // runInAction because Reflect.set could trigger a different observer\n    return runInAction(() => {\n      if (typeof key === \"symbol\") {\n        return Reflect.set(target, key, value, receiver);\n      }\n\n      // save if the object had a descriptor for this key\n      // execute the set operation before running any reaction\n      const hadKey = Object.hasOwnProperty.call(target, key);\n      // save if the value changed because of this set operation\n      const oldValue = Reflect.get(target, key, receiver);\n      const result = Reflect.set(target, key, value, receiver);\n\n      // queue a reaction if it's a new property or its value changed\n      if (!hadKey) {\n        reportChanged({ observable: target, key, value, type: \"add\" });\n      } else if (value !== oldValue) {\n        if (key === \"length\" && Array.isArray(target)) {\n          if (oldValue < value) {\n            // not necessary as values will still be undefined:\n            /*for (let i = oldValue; i <= value; i++) {\n            executeObservers({\n              observable: target as any,\n              key: \"\" + (i - 1),\n              value: undefined,\n              type: \"add\",\n            });\n          }*/\n          } else {\n            for (let i = value + 1; i <= oldValue; i++) {\n              // TODO: all of these will trigger the \"iterate\" listeners. That should only be triggered once\n              reportChanged({\n                observable: target as any,\n                key: \"\" + (i - 1),\n                oldValue: undefined, // Note: maybe we've just lost oldValue\n                type: \"delete\",\n              });\n            }\n          }\n        } else {\n          reportChanged({\n            observable: target,\n            key,\n            value,\n            oldValue,\n            type: \"update\",\n          });\n        }\n      }\n      return result;\n    });\n  },\n  deleteProperty(target: InternalObservable<any>, key: PropertyKey): boolean {\n    // runInAction because Reflect.deleteProperty could trigger a different observer\n    return runInAction(() => {\n      if (typeof key === \"symbol\") {\n        return Reflect.deleteProperty(target, key);\n      }\n\n      // save if the object had the key\n      const hadKey = Object.hasOwnProperty.call(target, key);\n      const oldValue = Reflect.get(target, key);\n      // execute the delete operation before running any reaction\n      const result = Reflect.deleteProperty(target, key);\n      // only queue reactions for delete operations which resulted in an actual change\n      if (hadKey) {\n        reportChanged({ observable: target, key, oldValue, type: \"delete\" });\n      }\n      return result;\n    });\n  },\n  preventExtensions(target) {\n    throw new Error(\"Dynamic observable objects cannot be frozen\");\n  },\n};\n","import { reactive } from \"./observable\";\nimport { Reaction } from \"./reaction\";\n\nexport function autorun<T>(\n  func: () => T extends Promise<void> ? never : T extends void ? T : never,\n  extraOptions?: { name?: string }\n): Reaction {\n  const options = { name: \"unnamed\", fireImmediately: true, ...extraOptions };\n  const reaction = new Reaction(func, options);\n\n  return reaction;\n}\n\nexport function autorunAsync<T>(\n  func: (reactive: T) => Promise<void>,\n  reactiveObject: T,\n  extraOptions?: { name?: string }\n): Reaction {\n  const options = { name: \"unnamed\", fireImmediately: true, ...extraOptions };\n  const reaction = new Reaction(() => {\n    func(reactiveObject); // TODO: error handling\n  }, options);\n  reactiveObject = reactive(reactiveObject, reaction);\n  if (options.fireImmediately) {\n    reaction.trigger();\n  }\n  return reaction;\n}\n","import { Observer } from \"./observer\";\nimport { reactive } from \"./observable\";\n\n// Hacky, it's not really an Atom in the sense that it is not the building block of observables\nexport class Atom {\n  private _observable = reactive({ _key: 1 });\n\n  public reportObserved(implicitObserver?: Observer) {\n    return (reactive(this._observable, implicitObserver)._key as any) as boolean;\n    //return (this._observable._key as any) as boolean;\n  }\n\n  public reportChanged() {\n    this._observable._key++;\n  }\n}\n\nexport function createAtom(name: string, onBecomeObservedHandler?: () => void, onBecomeUnobservedHandler?: () => void) {\n  // TODO: add support for params\n  return new Atom();\n}\n"],"names":["Observer","trigger","Map","registerConnection","source","existing","observing","get","observable","byKey","Set","iterate","set","type","add","key","removeObservers","forEach","val","$reactive","connections","delete","subkey","clear","runningReactions","Reaction","func","options","effect","_trigger","push","pop","isInitial","fireImmediately","Error","reaction","includes","hasRunningReaction","length","runningReaction","undefined","newOptions","name","r","runningActionCount","isActionRunning","runInAction","clearBatch","disableTracking","isTrackingDisabled","untracked","fn","untrackedCB","batch","copy","reportChangedArray","operations","toRun","operation","connection","observer","reportChanged","addConnection","reportObserved","implicitObserver","$skipreactive","Symbol","$reactiveproxy","isReactive","object","markRaw","isInternalObservable","shallow","_observable","proxy","proxiesWithImplicitObserver","proxyTraps","Object","setPrototypeOf","objectProxyTraps","Proxy","raw","reactive","value","defineProperty","enumerable","writable","configurable","has","target","result","Reflect","receiver","toString","console","error","Array","isArray","isFrozen","descriptor","getOwnPropertyDescriptor","ownKeys","hadKey","hasOwnProperty","call","oldValue","i","deleteProperty","preventExtensions","autorun","extraOptions","autorunAsync","reactiveObject","Atom","_key","createAtom","onBecomeObservedHandler","onBecomeUnobservedHandler"],"mappings":"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"}