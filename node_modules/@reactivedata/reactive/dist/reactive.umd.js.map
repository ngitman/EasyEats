{"version":3,"file":"reactive.umd.js","sources":["../src/observer.ts","../src/reaction.ts","../src/action.ts","../src/untracked.ts","../src/reporting.ts","../src/observable.ts","../src/autorun.ts","../src/atom.ts"],"sourcesContent":["import { $reactive, InternalObservable, ObserverConnection, ObserverConnectionSource } from \"./observable\";\n\nexport class Observer {\n  public observing = new Map<\n    InternalObservable<object>,\n    {\n      iterate: false | true;\n      byKey: Set<string | number>;\n    }\n  >();\n\n  constructor(public readonly trigger: () => void) {}\n\n  public registerConnection<T extends object>(source: ObserverConnectionSource<T>) {\n    let existing = this.observing.get(source.observable);\n    if (!existing) {\n      existing = {\n        byKey: new Set(),\n        iterate: false,\n      };\n      this.observing.set(source.observable, existing);\n    }\n    if (source.type === \"iterate\") {\n      existing.iterate = true;\n    } else {\n      existing.byKey.add(source.key);\n    }\n  }\n\n  public removeObservers() {\n    this.observing.forEach((val, key) => {\n      if (val.iterate) {\n        key[$reactive].connections.iterate.delete(this);\n      }\n      val.byKey.forEach((subkey) => {\n        key[$reactive].connections.byKey.get(subkey).delete(this);\n      });\n    });\n    this.observing.clear();\n  }\n}\n","import { Observer } from \"./observer\";\n\nlet runningReactions: Reaction[] = [];\nexport class Reaction extends Observer {\n  private isInitial = true;\n\n  constructor(\n    private func: () => void | Promise<void>,\n    private options: { fireImmediately: boolean; name: string },\n    private effect?: () => void | Promise<void>\n  ) {\n    super(() => this._trigger());\n\n    if (!effect && !this.options.fireImmediately) {\n      throw new Error(\"if no effect function passed, should always fireImmediately\");\n    }\n    // fire reaction\n    this.reaction();\n  }\n\n  private reaction = () => {\n    runningReactions.push(this);\n\n    try {\n      this.func();\n    } finally {\n      runningReactions.pop();\n    }\n\n    if (this.effect && (!this.isInitial || this.options.fireImmediately)) {\n      this.effect();\n    }\n    this.isInitial = false;\n  };\n\n  private _trigger() {\n    // TODO: catch errors\n    if (runningReactions.includes(this)) {\n      throw new Error(\"already running reaction\");\n    }\n    this.removeObservers();\n    this.reaction();\n  }\n}\n\nexport function hasRunningReaction() {\n  return !!runningReactions.length;\n}\n\nexport function runningReaction() {\n  return runningReactions.length ? runningReactions[runningReactions.length - 1] : undefined;\n}\n\nexport function reaction(\n  func: () => any | Promise<any>,\n  effect: () => void | Promise<void>,\n  options?: { fireImmediately?: boolean; name?: string }\n) {\n  const newOptions = { name: \"unnamed\", fireImmediately: true, ...options };\n  const r = new Reaction(func, newOptions, effect);\n  return r;\n}\n","import { clearBatch } from \"./reporting\";\n\nlet runningActionCount = 0;\n\nexport function isActionRunning() {\n  return runningActionCount > 0;\n}\n\nexport function runInAction<T>(func: () => T) {\n  runningActionCount++;\n  try {\n    return func();\n  } finally {\n    runningActionCount--;\n\n    if (runningActionCount === 0) {\n      clearBatch();\n    }\n  }\n}\n","let disableTracking = false;\n\nexport function isTrackingDisabled() {\n  return disableTracking;\n}\n\nexport function untracked(fn: () => void) {\n  disableTracking = true;\n  try {\n    fn();\n  } finally {\n    disableTracking = false;\n  }\n}\n\nexport function untrackedCB(fn: () => void) {\n  return () => untracked(fn);\n}\n","import { isActionRunning } from \"./action\";\nimport { $reactive, ObserverConnectionSource, Operation } from \"./observable\";\nimport { Observer } from \"./observer\";\nimport { runningReaction } from \"./reaction\";\nimport { isTrackingDisabled } from \"./untracked\";\n\nlet batch: Operation<any>[] = [];\n\nexport function clearBatch<T>() {\n  const copy = [...batch];\n  batch = [];\n  reportChangedArray(copy);\n}\n\nfunction reportChangedArray<T>(operations: Array<Operation<T>>) {\n  // create a copy because\n  // 1. the set observable[$reactive].connections will be changed while executing reactions (connections will be added / removed)\n  // 2. de-duplicate reactions (only run reactions once, for example if it's subscribed to both 'get' and 'iterate')\n  const toRun = new Set<Observer>();\n\n  operations.forEach((operation) => {\n    if (operation.type === \"add\" || operation.type === \"delete\") {\n      operation.observable[$reactive].connections.iterate.forEach((connection) => {\n        toRun.add(connection);\n      });\n    }\n    operation.observable[$reactive].connections.byKey.get(operation.key)?.forEach((connection) => {\n      toRun.add(connection);\n    });\n  });\n\n  toRun.forEach((observer) => {\n    observer.trigger();\n  });\n}\n\nexport function reportChanged<T>(operation: Operation<T>) {\n  if (isActionRunning()) {\n    batch.push(operation);\n    return;\n  }\n  reportChangedArray([operation]);\n}\n\nfunction addConnection<T>(source: ObserverConnectionSource<T>, observer: Observer) {\n  if (source.type === \"iterate\") {\n    source.observable[$reactive].connections.iterate.add(observer);\n  } else {\n    let set = source.observable[$reactive].connections.byKey.get(source.key);\n    if (!set) {\n      set = new Set<Observer>();\n      source.observable[$reactive].connections.byKey.set(source.key, set);\n    }\n    set.add(observer);\n  }\n}\n\nexport function reportObserved<T extends object>(source: ObserverConnectionSource<T>, implicitObserver: Observer) {\n  if (isTrackingDisabled()) {\n    return;\n  }\n\n  const reaction = runningReaction();\n  if (reaction) {\n    addConnection(source, reaction);\n    reaction.registerConnection(source);\n  }\n\n  if (implicitObserver) {\n    addConnection(source, implicitObserver);\n    implicitObserver.registerConnection(source);\n  }\n}\n","import { runInAction } from \".\";\nimport { Observer } from \"./observer\";\nimport { hasRunningReaction } from \"./reaction\";\nimport { reportChanged, reportObserved } from \"./reporting\";\n\nexport const $skipreactive = Symbol(\"$skipreactive\");\nexport const $reactive = Symbol(\"$reactive\");\nexport const $reactiveproxy = Symbol(\"$reactiveproxy\");\n\ntype Admin<T> = {\n  connections: {\n    iterate: Set<Observer>;\n    byKey: Map<string | number, Set<Observer>>;\n  };\n  proxy: InternalObservable<T>;\n  proxiesWithImplicitObserver: Map<Observer, InternalObservable<T>>;\n  raw: T;\n  shallow: boolean;\n};\nexport type InternalObservable<T> = {\n  [$reactive]: Admin<T>;\n} & T;\n\nexport function isReactive<T>(object: T, implicitObserver?: Observer): object is InternalObservable<T> {\n  return !!(\n    object &&\n    (object as any)[$reactiveproxy] &&\n    (object as any)[$reactiveproxy].implicitObserver === implicitObserver\n  );\n}\n\nexport function markRaw<T>(object: T) {\n  object[$skipreactive] = true;\n  return object;\n}\n\nfunction isInternalObservable<T>(object: T): object is InternalObservable<T> {\n  return !!(object && !isReactive(object) && (object as any)[$reactive]);\n}\n\nexport type ObserverConnectionSource<T> = {\n  observable: InternalObservable<T>;\n} & (\n  | {\n      key: string | number;\n      type: \"has\" | \"get\";\n    }\n  | {\n      type: \"iterate\";\n    }\n);\n\nexport type ObserverConnection<T> = {\n  source: ObserverConnectionSource<T>;\n  observer: Observer;\n};\n\nexport type Operation<T> = {\n  observable: InternalObservable<T>;\n  key: string | number;\n} & (\n  | {\n      value: any;\n      type: \"add\";\n    }\n  | { type: \"update\"; value: any; oldValue: any }\n  | { type: \"delete\"; oldValue: any }\n);\n\nfunction observable<T>(object: T, implicitObserver?: Observer, shallow = false) {\n  if (object[$skipreactive]) {\n    return object;\n  }\n\n  if (isReactive(object, implicitObserver)) {\n    return object;\n  }\n\n  const observable = _observable(object, shallow);\n\n  if (!implicitObserver) {\n    return observable;\n  }\n\n  let proxy = observable[$reactive].proxiesWithImplicitObserver.get(implicitObserver);\n  if (!proxy) {\n    const proxyTraps = {\n      implicitObserver,\n    } as any;\n    Object.setPrototypeOf(proxyTraps, objectProxyTraps);\n    proxy = new Proxy<InternalObservable<T>>(observable[$reactive].raw as any, proxyTraps);\n\n    observable[$reactive].proxiesWithImplicitObserver.set(implicitObserver, proxy);\n  }\n  return proxy;\n}\nexport const reactive = observable;\nfunction _observable<T>(object: T, shallow = false) {\n  if (isReactive(object)) {\n    return object;\n  }\n\n  if (isInternalObservable(object)) {\n    return object[$reactive].proxy;\n  }\n\n  if (object[$reactive] || object[$reactiveproxy]) {\n    throw new Error(\"unexpected\");\n  }\n  const value: Admin<T> = {\n    connections: {\n      iterate: new Set<Observer>(),\n      byKey: new Map<string | number, Set<Observer>>(),\n    },\n    proxy: {} as any, // temp\n    raw: object,\n    proxiesWithImplicitObserver: new Map(),\n    shallow,\n  };\n  Object.defineProperty(object, $reactive, {\n    enumerable: false,\n    writable: true,\n    configurable: true,\n    value,\n  });\n  const proxy = new Proxy<InternalObservable<T>>(object as any as InternalObservable<T>, objectProxyTraps);\n  value.proxy = proxy;\n  return proxy;\n}\n\nconst objectProxyTraps: ProxyHandler<InternalObservable<any>> = {\n  // Read:\n  has(target: InternalObservable<any>, key: PropertyKey): boolean {\n    const result = Reflect.has(target, key);\n\n    if (typeof key === \"symbol\") {\n      return result;\n    }\n\n    // register and save (observable.prop -> runningReaction)\n    reportObserved({ observable: target, key, type: \"has\" }, this.implicitObserver);\n    return result;\n  },\n  get(target: InternalObservable<any>, key: PropertyKey, receiver: any): any {\n    if (key === $reactiveproxy) {\n      // for isObservable\n      return { implicitObserver: this.implicitObserver };\n    }\n\n    const result = Reflect.get(target, key, receiver);\n\n    if (typeof key === \"symbol\") {\n      if (key.toString() === \"Symbol($reactiveproxy)\") {\n        console.error(\n          \"warning, Symbol($reactiveproxy) passed, but does not match $reactiveproxy. Multiple Reactive libraries loaded?\"\n        );\n      }\n      return result;\n    }\n\n    // register and save (observable.prop -> runningReaction)\n    if (key === \"length\" && Array.isArray(target)) {\n      reportObserved({ observable: target as any /* TODO */, type: \"iterate\" }, this.implicitObserver);\n    } else {\n      reportObserved({ observable: target, key, type: \"get\" }, this.implicitObserver);\n    }\n\n    if (isInternalObservable(result)) {\n      // already has an observable. Call observable() again to make sure we get the right proxy for implicitObserver\n      return observable(result, this.implicitObserver);\n    }\n\n    if (target[$reactive].shallow) {\n      return result;\n    }\n    // if we are inside a reaction and observable.prop is an object wrap it in an observable too\n    // this is needed to intercept property access on that object too (dynamic observable tree)\n    // const observableResult = rawToProxy.get(result)\n    if (\n      typeof result === \"object\" &&\n      result !== null &&\n      !isReactive(result, this.implicitObserver) &&\n      !Object.isFrozen(result)\n    ) {\n      // do not violate the none-configurable none-writable prop get handler invariant\n      // fall back to none reactive mode in this case, instead of letting the Proxy throw a TypeError\n      const descriptor = Reflect.getOwnPropertyDescriptor(target, key);\n      if (\n        (!descriptor || !(descriptor.writable === false && descriptor.configurable === false)) &&\n        (hasRunningReaction() || this.implicitObserver)\n      ) {\n        return observable(result, this.implicitObserver);\n      }\n    }\n    // otherwise return the observable wrapper if it is already created and cached or the raw object\n    return result;\n  },\n  ownKeys(target: InternalObservable<any>) {\n    reportObserved({ observable: target, type: \"iterate\" }, this.implicitObserver);\n    return Reflect.ownKeys(target);\n  },\n  // Write:\n  set(target: InternalObservable<any>, key: PropertyKey, value: any, receiver: any): boolean {\n    // runInAction because Reflect.set could trigger a different observer\n    return runInAction(() => {\n      if (typeof key === \"symbol\") {\n        return Reflect.set(target, key, value, receiver);\n      }\n\n      // save if the object had a descriptor for this key\n      // execute the set operation before running any reaction\n      const hadKey = Object.hasOwnProperty.call(target, key);\n      // save if the value changed because of this set operation\n      const oldValue = Reflect.get(target, key, receiver);\n      const result = Reflect.set(target, key, value, receiver);\n\n      // queue a reaction if it's a new property or its value changed\n      if (!hadKey) {\n        reportChanged({ observable: target, key, value, type: \"add\" });\n      } else if (value !== oldValue) {\n        if (key === \"length\" && Array.isArray(target)) {\n          if (oldValue < value) {\n            // not necessary as values will still be undefined:\n            /*for (let i = oldValue; i <= value; i++) {\n            executeObservers({\n              observable: target as any,\n              key: \"\" + (i - 1),\n              value: undefined,\n              type: \"add\",\n            });\n          }*/\n          } else {\n            for (let i = value + 1; i <= oldValue; i++) {\n              // TODO: all of these will trigger the \"iterate\" listeners. That should only be triggered once\n              reportChanged({\n                observable: target as any,\n                key: \"\" + (i - 1),\n                oldValue: undefined, // Note: maybe we've just lost oldValue\n                type: \"delete\",\n              });\n            }\n          }\n        } else {\n          reportChanged({\n            observable: target,\n            key,\n            value,\n            oldValue,\n            type: \"update\",\n          });\n        }\n      }\n      return result;\n    });\n  },\n  deleteProperty(target: InternalObservable<any>, key: PropertyKey): boolean {\n    // runInAction because Reflect.deleteProperty could trigger a different observer\n    return runInAction(() => {\n      if (typeof key === \"symbol\") {\n        return Reflect.deleteProperty(target, key);\n      }\n\n      // save if the object had the key\n      const hadKey = Object.hasOwnProperty.call(target, key);\n      const oldValue = Reflect.get(target, key);\n      // execute the delete operation before running any reaction\n      const result = Reflect.deleteProperty(target, key);\n      // only queue reactions for delete operations which resulted in an actual change\n      if (hadKey) {\n        reportChanged({ observable: target, key, oldValue, type: \"delete\" });\n      }\n      return result;\n    });\n  },\n  preventExtensions(target) {\n    throw new Error(\"Dynamic observable objects cannot be frozen\");\n  },\n};\n","import { reactive } from \"./observable\";\nimport { Reaction } from \"./reaction\";\n\nexport function autorun<T>(\n  func: () => T extends Promise<void> ? never : T extends void ? T : never,\n  extraOptions?: { name?: string }\n): Reaction {\n  const options = { name: \"unnamed\", fireImmediately: true, ...extraOptions };\n  const reaction = new Reaction(func, options);\n\n  return reaction;\n}\n\nexport function autorunAsync<T>(\n  func: (reactive: T) => Promise<void>,\n  reactiveObject: T,\n  extraOptions?: { name?: string }\n): Reaction {\n  const options = { name: \"unnamed\", fireImmediately: true, ...extraOptions };\n  const reaction = new Reaction(() => {\n    func(reactiveObject); // TODO: error handling\n  }, options);\n  reactiveObject = reactive(reactiveObject, reaction);\n  if (options.fireImmediately) {\n    reaction.trigger();\n  }\n  return reaction;\n}\n","import { Observer } from \"./observer\";\nimport { reactive } from \"./observable\";\n\n// Hacky, it's not really an Atom in the sense that it is not the building block of observables\nexport class Atom {\n  private _observable = reactive({ _key: 1 });\n\n  public reportObserved(implicitObserver?: Observer) {\n    return (reactive(this._observable, implicitObserver)._key as any) as boolean;\n    //return (this._observable._key as any) as boolean;\n  }\n\n  public reportChanged() {\n    this._observable._key++;\n  }\n}\n\nexport function createAtom(name: string, onBecomeObservedHandler?: () => void, onBecomeUnobservedHandler?: () => void) {\n  // TODO: add support for params\n  return new Atom();\n}\n"],"names":["Observer","trigger","Map","registerConnection","source","existing","observing","get","observable","byKey","Set","iterate","set","type","add","key","removeObservers","forEach","val","$reactive","connections","delete","subkey","clear","runningReactions","Reaction","func","options","effect","_trigger","push","pop","isInitial","fireImmediately","Error","reaction","includes","hasRunningReaction","length","runningReaction","undefined","newOptions","name","r","runningActionCount","isActionRunning","runInAction","clearBatch","disableTracking","isTrackingDisabled","untracked","fn","untrackedCB","batch","copy","reportChangedArray","operations","toRun","operation","connection","observer","reportChanged","addConnection","reportObserved","implicitObserver","$skipreactive","Symbol","$reactiveproxy","isReactive","object","markRaw","isInternalObservable","shallow","_observable","proxy","proxiesWithImplicitObserver","proxyTraps","Object","setPrototypeOf","objectProxyTraps","Proxy","raw","reactive","value","defineProperty","enumerable","writable","configurable","has","target","result","Reflect","receiver","toString","console","error","Array","isArray","isFrozen","descriptor","getOwnPropertyDescriptor","ownKeys","hadKey","hasOwnProperty","call","oldValue","i","deleteProperty","preventExtensions","autorun","extraOptions","autorunAsync","reactiveObject","Atom","_key","createAtom","onBecomeObservedHandler","onBecomeUnobservedHandler"],"mappings":"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"}