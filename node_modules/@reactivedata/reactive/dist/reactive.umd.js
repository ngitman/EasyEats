(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.reactive = {}));
}(this, (function (exports) {
  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  var Observer = /*#__PURE__*/function () {
    function Observer(trigger) {
      this.trigger = trigger;
      this.observing = new Map();
    }

    var _proto = Observer.prototype;

    _proto.registerConnection = function registerConnection(source) {
      var existing = this.observing.get(source.observable);

      if (!existing) {
        existing = {
          byKey: new Set(),
          iterate: false
        };
        this.observing.set(source.observable, existing);
      }

      if (source.type === "iterate") {
        existing.iterate = true;
      } else {
        existing.byKey.add(source.key);
      }
    };

    _proto.removeObservers = function removeObservers() {
      var _this = this;

      this.observing.forEach(function (val, key) {
        if (val.iterate) {
          key[$reactive].connections.iterate.delete(_this);
        }

        val.byKey.forEach(function (subkey) {
          key[$reactive].connections.byKey.get(subkey).delete(_this);
        });
      });
      this.observing.clear();
    };

    return Observer;
  }();

  var runningReactions = [];
  var Reaction = /*#__PURE__*/function (_Observer) {
    _inheritsLoose(Reaction, _Observer);

    function Reaction(func, options, effect) {
      var _this;

      _this = _Observer.call(this, function () {
        return _this._trigger();
      }) || this;
      _this.func = func;
      _this.options = options;
      _this.effect = effect;
      _this.isInitial = true;

      _this.reaction = function () {
        runningReactions.push(_assertThisInitialized(_this));

        try {
          _this.func();
        } finally {
          runningReactions.pop();
        }

        if (_this.effect && (!_this.isInitial || _this.options.fireImmediately)) {
          _this.effect();
        }

        _this.isInitial = false;
      };

      if (!effect && !_this.options.fireImmediately) {
        throw new Error("if no effect function passed, should always fireImmediately");
      } // fire reaction


      _this.reaction();

      return _this;
    }

    var _proto = Reaction.prototype;

    _proto._trigger = function _trigger() {
      // TODO: catch errors
      if (runningReactions.includes(this)) {
        throw new Error("already running reaction");
      }

      this.removeObservers();
      this.reaction();
    };

    return Reaction;
  }(Observer);
  function hasRunningReaction() {
    return !!runningReactions.length;
  }
  function runningReaction() {
    return runningReactions.length ? runningReactions[runningReactions.length - 1] : undefined;
  }
  function reaction(func, effect, options) {
    var newOptions = _extends({
      name: "unnamed",
      fireImmediately: true
    }, options);

    var r = new Reaction(func, newOptions, effect);
    return r;
  }

  var runningActionCount = 0;
  function isActionRunning() {
    return runningActionCount > 0;
  }
  function runInAction(func) {
    runningActionCount++;

    try {
      return func();
    } finally {
      runningActionCount--;

      if (runningActionCount === 0) {
        clearBatch();
      }
    }
  }

  var disableTracking = false;
  function isTrackingDisabled() {
    return disableTracking;
  }
  function untracked(fn) {
    disableTracking = true;

    try {
      fn();
    } finally {
      disableTracking = false;
    }
  }
  function untrackedCB(fn) {
    return function () {
      return untracked(fn);
    };
  }

  var batch = [];
  function clearBatch() {
    var copy = [].concat(batch);
    batch = [];
    reportChangedArray(copy);
  }

  function reportChangedArray(operations) {
    // create a copy because
    // 1. the set observable[$reactive].connections will be changed while executing reactions (connections will be added / removed)
    // 2. de-duplicate reactions (only run reactions once, for example if it's subscribed to both 'get' and 'iterate')
    var toRun = new Set();
    operations.forEach(function (operation) {
      var _operation$observable;

      if (operation.type === "add" || operation.type === "delete") {
        operation.observable[$reactive].connections.iterate.forEach(function (connection) {
          toRun.add(connection);
        });
      }

      (_operation$observable = operation.observable[$reactive].connections.byKey.get(operation.key)) == null ? void 0 : _operation$observable.forEach(function (connection) {
        toRun.add(connection);
      });
    });
    toRun.forEach(function (observer) {
      observer.trigger();
    });
  }

  function reportChanged(operation) {
    if (isActionRunning()) {
      batch.push(operation);
      return;
    }

    reportChangedArray([operation]);
  }

  function addConnection(source, observer) {
    if (source.type === "iterate") {
      source.observable[$reactive].connections.iterate.add(observer);
    } else {
      var set = source.observable[$reactive].connections.byKey.get(source.key);

      if (!set) {
        set = new Set();
        source.observable[$reactive].connections.byKey.set(source.key, set);
      }

      set.add(observer);
    }
  }

  function reportObserved(source, implicitObserver) {
    if (isTrackingDisabled()) {
      return;
    }

    var reaction = runningReaction();

    if (reaction) {
      addConnection(source, reaction);
      reaction.registerConnection(source);
    }

    if (implicitObserver) {
      addConnection(source, implicitObserver);
      implicitObserver.registerConnection(source);
    }
  }

  var $skipreactive = Symbol("$skipreactive");
  var $reactive = Symbol("$reactive");
  var $reactiveproxy = Symbol("$reactiveproxy");
  function isReactive(object, implicitObserver) {
    return !!(object && object[$reactiveproxy] && object[$reactiveproxy].implicitObserver === implicitObserver);
  }
  function markRaw(object) {
    object[$skipreactive] = true;
    return object;
  }

  function isInternalObservable(object) {
    return !!(object && !isReactive(object) && object[$reactive]);
  }

  function observable(object, implicitObserver, shallow) {
    if (shallow === void 0) {
      shallow = false;
    }

    if (object[$skipreactive]) {
      return object;
    }

    if (isReactive(object, implicitObserver)) {
      return object;
    }

    var observable = _observable(object, shallow);

    if (!implicitObserver) {
      return observable;
    }

    var proxy = observable[$reactive].proxiesWithImplicitObserver.get(implicitObserver);

    if (!proxy) {
      var proxyTraps = {
        implicitObserver: implicitObserver
      };
      Object.setPrototypeOf(proxyTraps, objectProxyTraps);
      proxy = new Proxy(observable[$reactive].raw, proxyTraps);
      observable[$reactive].proxiesWithImplicitObserver.set(implicitObserver, proxy);
    }

    return proxy;
  }

  var reactive = observable;

  function _observable(object, shallow) {
    if (shallow === void 0) {
      shallow = false;
    }

    if (isReactive(object)) {
      return object;
    }

    if (isInternalObservable(object)) {
      return object[$reactive].proxy;
    }

    if (object[$reactive] || object[$reactiveproxy]) {
      throw new Error("unexpected");
    }

    var value = {
      connections: {
        iterate: new Set(),
        byKey: new Map()
      },
      proxy: {},
      raw: object,
      proxiesWithImplicitObserver: new Map(),
      shallow: shallow
    };
    Object.defineProperty(object, $reactive, {
      enumerable: false,
      writable: true,
      configurable: true,
      value: value
    });
    var proxy = new Proxy(object, objectProxyTraps);
    value.proxy = proxy;
    return proxy;
  }

  var objectProxyTraps = {
    // Read:
    has: function has(target, key) {
      var result = Reflect.has(target, key);

      if (typeof key === "symbol") {
        return result;
      } // register and save (observable.prop -> runningReaction)


      reportObserved({
        observable: target,
        key: key,
        type: "has"
      }, this.implicitObserver);
      return result;
    },
    get: function get(target, key, receiver) {
      if (key === $reactiveproxy) {
        // for isObservable
        return {
          implicitObserver: this.implicitObserver
        };
      }

      var result = Reflect.get(target, key, receiver);

      if (typeof key === "symbol") {
        if (key.toString() === "Symbol($reactiveproxy)") {
          console.error("warning, Symbol($reactiveproxy) passed, but does not match $reactiveproxy. Multiple Reactive libraries loaded?");
        }

        return result;
      } // register and save (observable.prop -> runningReaction)


      if (key === "length" && Array.isArray(target)) {
        reportObserved({
          observable: target
          /* TODO */
          ,
          type: "iterate"
        }, this.implicitObserver);
      } else {
        reportObserved({
          observable: target,
          key: key,
          type: "get"
        }, this.implicitObserver);
      }

      if (isInternalObservable(result)) {
        // already has an observable. Call observable() again to make sure we get the right proxy for implicitObserver
        return observable(result, this.implicitObserver);
      }

      if (target[$reactive].shallow) {
        return result;
      } // if we are inside a reaction and observable.prop is an object wrap it in an observable too
      // this is needed to intercept property access on that object too (dynamic observable tree)
      // const observableResult = rawToProxy.get(result)


      if (typeof result === "object" && result !== null && !isReactive(result, this.implicitObserver) && !Object.isFrozen(result)) {
        // do not violate the none-configurable none-writable prop get handler invariant
        // fall back to none reactive mode in this case, instead of letting the Proxy throw a TypeError
        var descriptor = Reflect.getOwnPropertyDescriptor(target, key);

        if ((!descriptor || !(descriptor.writable === false && descriptor.configurable === false)) && (hasRunningReaction() || this.implicitObserver)) {
          return observable(result, this.implicitObserver);
        }
      } // otherwise return the observable wrapper if it is already created and cached or the raw object


      return result;
    },
    ownKeys: function ownKeys(target) {
      reportObserved({
        observable: target,
        type: "iterate"
      }, this.implicitObserver);
      return Reflect.ownKeys(target);
    },
    // Write:
    set: function set(target, key, value, receiver) {
      // runInAction because Reflect.set could trigger a different observer
      return runInAction(function () {
        if (typeof key === "symbol") {
          return Reflect.set(target, key, value, receiver);
        } // save if the object had a descriptor for this key
        // execute the set operation before running any reaction


        var hadKey = Object.hasOwnProperty.call(target, key); // save if the value changed because of this set operation

        var oldValue = Reflect.get(target, key, receiver);
        var result = Reflect.set(target, key, value, receiver); // queue a reaction if it's a new property or its value changed

        if (!hadKey) {
          reportChanged({
            observable: target,
            key: key,
            value: value,
            type: "add"
          });
        } else if (value !== oldValue) {
          if (key === "length" && Array.isArray(target)) {
            if (oldValue < value) {// not necessary as values will still be undefined:

              /*for (let i = oldValue; i <= value; i++) {
              executeObservers({
                observable: target as any,
                key: "" + (i - 1),
                value: undefined,
                type: "add",
              });
              }*/
            } else {
              for (var i = value + 1; i <= oldValue; i++) {
                // TODO: all of these will trigger the "iterate" listeners. That should only be triggered once
                reportChanged({
                  observable: target,
                  key: "" + (i - 1),
                  oldValue: undefined,
                  type: "delete"
                });
              }
            }
          } else {
            reportChanged({
              observable: target,
              key: key,
              value: value,
              oldValue: oldValue,
              type: "update"
            });
          }
        }

        return result;
      });
    },
    deleteProperty: function deleteProperty(target, key) {
      // runInAction because Reflect.deleteProperty could trigger a different observer
      return runInAction(function () {
        if (typeof key === "symbol") {
          return Reflect.deleteProperty(target, key);
        } // save if the object had the key


        var hadKey = Object.hasOwnProperty.call(target, key);
        var oldValue = Reflect.get(target, key); // execute the delete operation before running any reaction

        var result = Reflect.deleteProperty(target, key); // only queue reactions for delete operations which resulted in an actual change

        if (hadKey) {
          reportChanged({
            observable: target,
            key: key,
            oldValue: oldValue,
            type: "delete"
          });
        }

        return result;
      });
    },
    preventExtensions: function preventExtensions(target) {
      throw new Error("Dynamic observable objects cannot be frozen");
    }
  };

  function autorun(func, extraOptions) {
    var options = _extends({
      name: "unnamed",
      fireImmediately: true
    }, extraOptions);

    var reaction = new Reaction(func, options);
    return reaction;
  }
  function autorunAsync(func, reactiveObject, extraOptions) {
    var options = _extends({
      name: "unnamed",
      fireImmediately: true
    }, extraOptions);

    var reaction = new Reaction(function () {
      func(reactiveObject); // TODO: error handling
    }, options);
    reactiveObject = reactive(reactiveObject, reaction);

    if (options.fireImmediately) {
      reaction.trigger();
    }

    return reaction;
  }

  var Atom = /*#__PURE__*/function () {
    function Atom() {
      this._observable = reactive({
        _key: 1
      });
    }

    var _proto = Atom.prototype;

    _proto.reportObserved = function reportObserved(implicitObserver) {
      return reactive(this._observable, implicitObserver)._key; //return (this._observable._key as any) as boolean;
    };

    _proto.reportChanged = function reportChanged() {
      this._observable._key++;
    };

    return Atom;
  }();
  function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
    // TODO: add support for params
    return new Atom();
  }

  exports.$reactive = $reactive;
  exports.$reactiveproxy = $reactiveproxy;
  exports.$skipreactive = $skipreactive;
  exports.Atom = Atom;
  exports.Observer = Observer;
  exports.Reaction = Reaction;
  exports.autorun = autorun;
  exports.autorunAsync = autorunAsync;
  exports.createAtom = createAtom;
  exports.hasRunningReaction = hasRunningReaction;
  exports.isActionRunning = isActionRunning;
  exports.isReactive = isReactive;
  exports.isTrackingDisabled = isTrackingDisabled;
  exports.markRaw = markRaw;
  exports.reaction = reaction;
  exports.reactive = reactive;
  exports.runInAction = runInAction;
  exports.runningReaction = runningReaction;
  exports.untracked = untracked;
  exports.untrackedCB = untrackedCB;

})));
//# sourceMappingURL=reactive.umd.js.map
