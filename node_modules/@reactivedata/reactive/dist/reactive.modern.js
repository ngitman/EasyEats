function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

class Observer {
  constructor(trigger) {
    this.trigger = trigger;
    this.observing = new Map();
  }

  registerConnection(source) {
    let existing = this.observing.get(source.observable);

    if (!existing) {
      existing = {
        byKey: new Set(),
        iterate: false
      };
      this.observing.set(source.observable, existing);
    }

    if (source.type === "iterate") {
      existing.iterate = true;
    } else {
      existing.byKey.add(source.key);
    }
  }

  removeObservers() {
    this.observing.forEach((val, key) => {
      if (val.iterate) {
        key[$reactive].connections.iterate.delete(this);
      }

      val.byKey.forEach(subkey => {
        key[$reactive].connections.byKey.get(subkey).delete(this);
      });
    });
    this.observing.clear();
  }

}

let runningReactions = [];
class Reaction extends Observer {
  constructor(func, options, effect) {
    super(() => this._trigger());
    this.func = func;
    this.options = options;
    this.effect = effect;
    this.isInitial = true;

    this.reaction = () => {
      runningReactions.push(this);

      try {
        this.func();
      } finally {
        runningReactions.pop();
      }

      if (this.effect && (!this.isInitial || this.options.fireImmediately)) {
        this.effect();
      }

      this.isInitial = false;
    };

    if (!effect && !this.options.fireImmediately) {
      throw new Error("if no effect function passed, should always fireImmediately");
    } // fire reaction


    this.reaction();
  }

  _trigger() {
    // TODO: catch errors
    if (runningReactions.includes(this)) {
      throw new Error("already running reaction");
    }

    this.removeObservers();
    this.reaction();
  }

}
function hasRunningReaction() {
  return !!runningReactions.length;
}
function runningReaction() {
  return runningReactions.length ? runningReactions[runningReactions.length - 1] : undefined;
}
function reaction(func, effect, options) {
  const newOptions = _extends({
    name: "unnamed",
    fireImmediately: true
  }, options);

  const r = new Reaction(func, newOptions, effect);
  return r;
}

let runningActionCount = 0;
function isActionRunning() {
  return runningActionCount > 0;
}
function runInAction(func) {
  runningActionCount++;

  try {
    return func();
  } finally {
    runningActionCount--;

    if (runningActionCount === 0) {
      clearBatch();
    }
  }
}

let disableTracking = false;
function isTrackingDisabled() {
  return disableTracking;
}
function untracked(fn) {
  disableTracking = true;

  try {
    fn();
  } finally {
    disableTracking = false;
  }
}
function untrackedCB(fn) {
  return () => untracked(fn);
}

let batch = [];
function clearBatch() {
  const copy = [...batch];
  batch = [];
  reportChangedArray(copy);
}

function reportChangedArray(operations) {
  // create a copy because
  // 1. the set observable[$reactive].connections will be changed while executing reactions (connections will be added / removed)
  // 2. de-duplicate reactions (only run reactions once, for example if it's subscribed to both 'get' and 'iterate')
  const toRun = new Set();
  operations.forEach(operation => {
    var _operation$observable;

    if (operation.type === "add" || operation.type === "delete") {
      operation.observable[$reactive].connections.iterate.forEach(connection => {
        toRun.add(connection);
      });
    }

    (_operation$observable = operation.observable[$reactive].connections.byKey.get(operation.key)) == null ? void 0 : _operation$observable.forEach(connection => {
      toRun.add(connection);
    });
  });
  toRun.forEach(observer => {
    observer.trigger();
  });
}

function reportChanged(operation) {
  if (isActionRunning()) {
    batch.push(operation);
    return;
  }

  reportChangedArray([operation]);
}

function addConnection(source, observer) {
  if (source.type === "iterate") {
    source.observable[$reactive].connections.iterate.add(observer);
  } else {
    let set = source.observable[$reactive].connections.byKey.get(source.key);

    if (!set) {
      set = new Set();
      source.observable[$reactive].connections.byKey.set(source.key, set);
    }

    set.add(observer);
  }
}

function reportObserved(source, implicitObserver) {
  if (isTrackingDisabled()) {
    return;
  }

  const reaction = runningReaction();

  if (reaction) {
    addConnection(source, reaction);
    reaction.registerConnection(source);
  }

  if (implicitObserver) {
    addConnection(source, implicitObserver);
    implicitObserver.registerConnection(source);
  }
}

const $skipreactive = Symbol("$skipreactive");
const $reactive = Symbol("$reactive");
const $reactiveproxy = Symbol("$reactiveproxy");
function isReactive(object, implicitObserver) {
  return !!(object && object[$reactiveproxy] && object[$reactiveproxy].implicitObserver === implicitObserver);
}
function markRaw(object) {
  object[$skipreactive] = true;
  return object;
}

function isInternalObservable(object) {
  return !!(object && !isReactive(object) && object[$reactive]);
}

function observable(object, implicitObserver, shallow = false) {
  if (object[$skipreactive]) {
    return object;
  }

  if (isReactive(object, implicitObserver)) {
    return object;
  }

  const observable = _observable(object, shallow);

  if (!implicitObserver) {
    return observable;
  }

  let proxy = observable[$reactive].proxiesWithImplicitObserver.get(implicitObserver);

  if (!proxy) {
    const proxyTraps = {
      implicitObserver
    };
    Object.setPrototypeOf(proxyTraps, objectProxyTraps);
    proxy = new Proxy(observable[$reactive].raw, proxyTraps);
    observable[$reactive].proxiesWithImplicitObserver.set(implicitObserver, proxy);
  }

  return proxy;
}

const reactive = observable;

function _observable(object, shallow = false) {
  if (isReactive(object)) {
    return object;
  }

  if (isInternalObservable(object)) {
    return object[$reactive].proxy;
  }

  if (object[$reactive] || object[$reactiveproxy]) {
    throw new Error("unexpected");
  }

  const value = {
    connections: {
      iterate: new Set(),
      byKey: new Map()
    },
    proxy: {},
    raw: object,
    proxiesWithImplicitObserver: new Map(),
    shallow
  };
  Object.defineProperty(object, $reactive, {
    enumerable: false,
    writable: true,
    configurable: true,
    value
  });
  const proxy = new Proxy(object, objectProxyTraps);
  value.proxy = proxy;
  return proxy;
}

const objectProxyTraps = {
  // Read:
  has(target, key) {
    const result = Reflect.has(target, key);

    if (typeof key === "symbol") {
      return result;
    } // register and save (observable.prop -> runningReaction)


    reportObserved({
      observable: target,
      key,
      type: "has"
    }, this.implicitObserver);
    return result;
  },

  get(target, key, receiver) {
    if (key === $reactiveproxy) {
      // for isObservable
      return {
        implicitObserver: this.implicitObserver
      };
    }

    const result = Reflect.get(target, key, receiver);

    if (typeof key === "symbol") {
      if (key.toString() === "Symbol($reactiveproxy)") {
        console.error("warning, Symbol($reactiveproxy) passed, but does not match $reactiveproxy. Multiple Reactive libraries loaded?");
      }

      return result;
    } // register and save (observable.prop -> runningReaction)


    if (key === "length" && Array.isArray(target)) {
      reportObserved({
        observable: target
        /* TODO */
        ,
        type: "iterate"
      }, this.implicitObserver);
    } else {
      reportObserved({
        observable: target,
        key,
        type: "get"
      }, this.implicitObserver);
    }

    if (isInternalObservable(result)) {
      // already has an observable. Call observable() again to make sure we get the right proxy for implicitObserver
      return observable(result, this.implicitObserver);
    }

    if (target[$reactive].shallow) {
      return result;
    } // if we are inside a reaction and observable.prop is an object wrap it in an observable too
    // this is needed to intercept property access on that object too (dynamic observable tree)
    // const observableResult = rawToProxy.get(result)


    if (typeof result === "object" && result !== null && !isReactive(result, this.implicitObserver) && !Object.isFrozen(result)) {
      // do not violate the none-configurable none-writable prop get handler invariant
      // fall back to none reactive mode in this case, instead of letting the Proxy throw a TypeError
      const descriptor = Reflect.getOwnPropertyDescriptor(target, key);

      if ((!descriptor || !(descriptor.writable === false && descriptor.configurable === false)) && (hasRunningReaction() || this.implicitObserver)) {
        return observable(result, this.implicitObserver);
      }
    } // otherwise return the observable wrapper if it is already created and cached or the raw object


    return result;
  },

  ownKeys(target) {
    reportObserved({
      observable: target,
      type: "iterate"
    }, this.implicitObserver);
    return Reflect.ownKeys(target);
  },

  // Write:
  set(target, key, value, receiver) {
    // runInAction because Reflect.set could trigger a different observer
    return runInAction(() => {
      if (typeof key === "symbol") {
        return Reflect.set(target, key, value, receiver);
      } // save if the object had a descriptor for this key
      // execute the set operation before running any reaction


      const hadKey = Object.hasOwnProperty.call(target, key); // save if the value changed because of this set operation

      const oldValue = Reflect.get(target, key, receiver);
      const result = Reflect.set(target, key, value, receiver); // queue a reaction if it's a new property or its value changed

      if (!hadKey) {
        reportChanged({
          observable: target,
          key,
          value,
          type: "add"
        });
      } else if (value !== oldValue) {
        if (key === "length" && Array.isArray(target)) {
          if (oldValue < value) {// not necessary as values will still be undefined:

            /*for (let i = oldValue; i <= value; i++) {
            executeObservers({
              observable: target as any,
              key: "" + (i - 1),
              value: undefined,
              type: "add",
            });
            }*/
          } else {
            for (let i = value + 1; i <= oldValue; i++) {
              // TODO: all of these will trigger the "iterate" listeners. That should only be triggered once
              reportChanged({
                observable: target,
                key: "" + (i - 1),
                oldValue: undefined,
                type: "delete"
              });
            }
          }
        } else {
          reportChanged({
            observable: target,
            key,
            value,
            oldValue,
            type: "update"
          });
        }
      }

      return result;
    });
  },

  deleteProperty(target, key) {
    // runInAction because Reflect.deleteProperty could trigger a different observer
    return runInAction(() => {
      if (typeof key === "symbol") {
        return Reflect.deleteProperty(target, key);
      } // save if the object had the key


      const hadKey = Object.hasOwnProperty.call(target, key);
      const oldValue = Reflect.get(target, key); // execute the delete operation before running any reaction

      const result = Reflect.deleteProperty(target, key); // only queue reactions for delete operations which resulted in an actual change

      if (hadKey) {
        reportChanged({
          observable: target,
          key,
          oldValue,
          type: "delete"
        });
      }

      return result;
    });
  },

  preventExtensions(target) {
    throw new Error("Dynamic observable objects cannot be frozen");
  }

};

function autorun(func, extraOptions) {
  const options = _extends({
    name: "unnamed",
    fireImmediately: true
  }, extraOptions);

  const reaction = new Reaction(func, options);
  return reaction;
}
function autorunAsync(func, reactiveObject, extraOptions) {
  const options = _extends({
    name: "unnamed",
    fireImmediately: true
  }, extraOptions);

  const reaction = new Reaction(() => {
    func(reactiveObject); // TODO: error handling
  }, options);
  reactiveObject = reactive(reactiveObject, reaction);

  if (options.fireImmediately) {
    reaction.trigger();
  }

  return reaction;
}

class Atom {
  constructor() {
    this._observable = reactive({
      _key: 1
    });
  }

  reportObserved(implicitObserver) {
    return reactive(this._observable, implicitObserver)._key; //return (this._observable._key as any) as boolean;
  }

  reportChanged() {
    this._observable._key++;
  }

}
function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
  // TODO: add support for params
  return new Atom();
}

export { $reactive, $reactiveproxy, $skipreactive, Atom, Observer, Reaction, autorun, autorunAsync, createAtom, hasRunningReaction, isActionRunning, isReactive, isTrackingDisabled, markRaw, reaction, reactive, runInAction, runningReaction, untracked, untrackedCB };
//# sourceMappingURL=reactive.modern.js.map
