// src/index.ts
import { Command } from "commander";

// src/config.ts
var EnvironmentVariableConfig = class {
  constructor(config) {
    this.config = config;
  }
  get(key) {
    return this.config[key];
  }
  set(key, value) {
    throw new Error("set undefined");
  }
};
var getConfig = async (isLocal = false) => {
  if (process.env.SOUL_ENGINE_CONFIG) {
    console.log("login with config");
    const parsed = JSON.parse(Buffer.from(process.env.SOUL_ENGINE_CONFIG, "base64").toString("utf8"));
    return new EnvironmentVariableConfig({
      apiKey: parsed.apiKey,
      organization: parsed.organization.slug
    });
  }
  if (process.env.SOUL_ENGINE_API_KEY && process.env.SOUL_ENGINE_ORGANIZATION) {
    return new EnvironmentVariableConfig({
      apiKey: process.env.SOUL_ENGINE_API_KEY,
      organization: process.env.SOUL_ENGINE_ORGANIZATION
    });
  }
  const { default: Conf } = await import("conf");
  const projectName = isLocal ? "soul-engine-cli-local" : "soul-engine-cli";
  return new Conf({ projectName });
};

// src/commands/apikey.ts
var createApiKeyCommand = (program) => {
  program.command("apikey").description("print your api key to the terminal. This command is useful for connecting to a debug chat.").option("-l, --local", "use the local config file", false).option("--json", "output the api key and organization as json", false).action(async (options) => {
    const globalConfig = await getConfig(options.local);
    const org = globalConfig.get("organization");
    const apiKey = globalConfig.get("apiKey");
    if (options.json) {
      console.log(JSON.stringify({
        apiKey,
        organization: org
      }));
      return;
    }
    console.log("API KEY:", apiKey);
    console.log("ORGANIZATION: ", org);
  });
};
var apikey_default = createApiKeyCommand;

// src/commands/dev.ts
import { existsSync as existsSync2, readFileSync as readFileSync3 } from "node:fs";
import path3 from "node:path";
import { v4 as uuidv4 } from "uuid";

// src/debugChat/file-poster.ts
import { HocuspocusProvider } from "@hocuspocus/provider";
import { getYjsDoc, syncedStore } from "@syncedstore/core";
import { EventEmitter } from "eventemitter3";

// src/fileSystem/file-watcher.ts
import { watch } from "chokidar";
import fs, { readdirSync } from "node:fs";
import path, { basename, dirname, join } from "node:path";
import process2 from "node:process";
var caseSensitiveExistsSync = (path7) => readdirSync(dirname(path7)).includes(basename(path7));
var FileWatcher = class {
  constructor(options) {
    this.options = options;
    this.paths = options.paths;
    this.root = options.root;
    console.log("paths:", this.paths, "cwd", this.root);
    console.log("Watcher constructor");
  }
  async start() {
    return this.watch();
  }
  async callOnUpdate(files) {
    if (!this.onFileUpdate) {
      return;
    }
    this.onFileUpdate(files.map((filePath) => {
      try {
        console.log("file update:", filePath);
        if (filePath === "") {
          return null;
        }
        const fullPath = join(this.root, filePath);
        const remotePath = filePath.split(path.sep).join("/");
        const exists = caseSensitiveExistsSync(fullPath);
        if (!exists) {
          return {
            content: "",
            relativePath: remotePath,
            removed: true
          };
        }
        const stat = fs.statSync(fullPath);
        if (!stat.isFile()) {
          return null;
        }
        return {
          content: fs.readFileSync(fullPath, { encoding: "utf8" }),
          relativePath: remotePath
        };
      } catch (error) {
        console.error("error reading file:", filePath, error);
        throw error;
      }
    }).filter(Boolean));
  }
  watch() {
    let timeoutId = null;
    const changedFiles = /* @__PURE__ */ new Set();
    const scheduleUpdate = (filepath) => {
      if (this.options.allowedExtensions && !this.options.allowedExtensions.includes(path.extname(filepath))) {
        console.warn("Ignoring file", filepath);
        return;
      }
      changedFiles.add(filepath);
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      timeoutId = setTimeout(() => {
        timeoutId = null;
        this.callOnUpdate([...changedFiles]);
        changedFiles.clear();
      }, 300);
    };
    const watcher = watch(this.paths, {
      ignored: [
        /(^|[/\\])\../,
        // ignore dotfiles
        /node_modules/,
        // ignore node_modules
        /tsconfig\.json/
        // ignore tsconfig.json
      ],
      persistent: true,
      cwd: this.root
    });
    watcher.on("add", (path7) => console.log(`File ${path7} has been added`)).on("change", (path7) => console.log(`File ${path7} has been changed`)).on("unlink", (path7) => console.log(`File ${path7} has been removed`)).on("addDir", (path7) => console.log(`Directory ${path7} has been added`)).on("unlinkDir", (path7) => console.log(`Directory ${path7} has been removed`)).on("error", (error) => console.error(`Watcher error: ${error}`)).on("ready", () => console.log("Initial scan complete. Ready for changes")).on("all", (event, path7) => {
      scheduleUpdate(path7);
    });
    process2.once("SIGINT", () => {
      watcher.close();
    });
    return watcher;
  }
};

// src/sockets/soul-engine-socket.ts
import { HocuspocusProviderWebsocket } from "@hocuspocus/provider";
var websocketUrl = (organizationSlug, local, debug) => {
  const urlpath = debug ? "debug-chat" : "experience";
  return local ? `ws://localhost:4000/${organizationSlug}/${urlpath}` : `wss://servers.souls.chat/${organizationSlug}/${urlpath}`;
};
var getConnectedWebsocket = (organizationSlug, local, debug, opts = {}) => new HocuspocusProviderWebsocket({
  url: websocketUrl(organizationSlug, local, debug),
  ...opts
});

// src/debugChat/file-poster.ts
var docShape = {
  files: {}
  // relativePath, conent
};
var syncedFilesDoc = () => syncedStore(docShape);
var FilePoster = class extends EventEmitter {
  constructor({ apiKey, paths, root, organizationSlug, blueprint, local }) {
    super();
    this.firstSync = true;
    this.watcher = new FileWatcher({ paths, root });
    this.watcher.onFileUpdate = (files) => {
      this.onFileUpdate(files);
    };
    this.connectionOpts = {
      organizationSlug,
      blueprint,
      local
    };
    this.apiKey = apiKey;
  }
  async start() {
    await this.setupProvider();
    return this.watcher.start();
  }
  stop() {
    if (!this._connection) {
      return;
    }
    this._connection.provider.destroy();
    this._connection.socket.destroy();
  }
  async onFileUpdate(files) {
    console.log("updating:", files.map((f) => f.relativePath));
    if (!this._connection) {
      throw new Error("missing connection");
    }
    const { doc, provider } = this._connection;
    getYjsDoc(doc).transact(() => {
      if (this.firstSync) {
        for (const key of Object.keys(doc.files)) {
          delete doc.files[key];
        }
      }
      this.firstSync = false;
      for (const file of files) {
        if (file.removed) {
          delete doc.files[file.relativePath];
          continue;
        }
        doc.files[file.relativePath] = file.content;
      }
    });
    provider.sendStateless(JSON.stringify({
      event: "codeSync",
      data: ""
    }));
    this.emit("fileUpdate", files);
  }
  async setupProvider() {
    const { default: ws } = await import("ws");
    const { organizationSlug, blueprint, local } = this.connectionOpts;
    const docName = `soul-source-doc.${organizationSlug}.${blueprint}`;
    const doc = syncedFilesDoc();
    const socket = getConnectedWebsocket(organizationSlug, Boolean(local), false, { WebSocketPolyfill: ws });
    return new Promise((resolve, reject) => {
      const provider = new HocuspocusProvider({
        document: getYjsDoc(doc),
        name: docName,
        async onAuthenticationFailed({ reason }) {
          console.error("authentication failed", reason);
          reject(reason);
        },
        onStateless: async ({ payload }) => {
          this.emit("stateless");
          console.log(/* @__PURE__ */ new Date(), payload);
        },
        onSynced: async () => {
          this._connection = {
            doc,
            provider,
            socket
          };
          resolve(this._connection);
        },
        token: this.apiKey,
        websocketProvider: socket
      });
    });
  }
};

// src/login.ts
import readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";
var handleLogin = async (local, force = false) => {
  const rl = readline.createInterface({ input, output });
  const globalConfig = await getConfig(local);
  if (globalConfig.get("apiKey") && !force) {
    return;
  }
  const { default: open } = await import("open");
  const url = local ? "http://localhost:3000/auth/cli" : "https://souls.chat/auth/cli";
  open(url);
  console.log(`Opening ${url} in your browser. If the browser does not open, then please visit manually.`);
  const configInput = await rl.question("Please login to the soul engine and then paste the config here: ");
  rl.close();
  const responses = { configInput };
  const pasted = responses.configInput;
  const pastedConfig = JSON.parse(Buffer.from(pasted, "base64").toString("utf8"));
  console.log(`logged into ${pastedConfig.organization.name} as ${pastedConfig.user.email}`);
  globalConfig.set("apiKey", pastedConfig.apiKey);
  globalConfig.set("organization", pastedConfig.organization.slug);
};

// src/rag/rag-file-poster.ts
import fetch2 from "cross-fetch";
import fs3, { existsSync, readFileSync as readFileSync2 } from "node:fs";
import { join as join3, relative } from "node:path";

// src/fileSystem/recursive-reader.ts
import fs2 from "node:fs";
import path2 from "node:path";
function readDirRecursive(directory) {
  let results = [];
  const list = fs2.readdirSync(directory);
  for (const listFile of list) {
    const file = path2.join(directory.toString(), listFile);
    const stat = fs2.statSync(file);
    if (stat && stat.isDirectory()) {
      results = [...results, ...readDirRecursive(file)];
    } else {
      results.push(file);
    }
  }
  return results;
}

// src/rag/rag-file-poster.ts
import { ALLOWED_RAG_FILE_EXTENSIONS, defaultRagBucketName } from "@opensouls/engine";

// src/packageParser.ts
import { join as join2 } from "node:path";
import { readFileSync } from "node:fs";
var parsedPackageJson = () => {
  const packageJsonPath = join2(".", "package.json");
  return JSON.parse(readFileSync(packageJsonPath, { encoding: "utf8" }));
};

// src/rag/rag-file-poster.ts
var RagPoster = class _RagPoster {
  constructor({ apiKey, path: path7, url }) {
    this.url = url;
    console.log("file poster url:", this.url);
    this.apiKey = apiKey || "";
    this.path = path7;
  }
  static createWithDefaultConfig({ path: path7, organization, local, apiKey }) {
    const ragDir = path7;
    const pathToRagConfig = join3(ragDir, "rag.json");
    const pathToPackageJson = join3(".", "package.json");
    const ragConfigExists = existsSync(pathToRagConfig);
    const packageJsonExists = existsSync(pathToPackageJson);
    if (!ragConfigExists && !packageJsonExists) {
      throw new Error("Neither rag.json nor package.json exists in the specified directory.");
    }
    let bucketName;
    if (ragConfigExists) {
      const ragConfig = JSON.parse(readFileSync2(pathToRagConfig, { encoding: "utf8" }));
      bucketName = ragConfig.bucket;
    } else {
      bucketName = defaultRagBucketName(parsedPackageJson().name);
    }
    console.log("RAG bucket name:", bucketName);
    const url = local ? `http://localhost:4000/api/${organization}/rag-ingest/${bucketName}` : `https://servers.souls.chat/api/${organization}/rag-ingest/${bucketName}`;
    return new _RagPoster({
      apiKey,
      path: ragDir,
      url
    });
  }
  async push() {
    return this.pushFiles(...readDirRecursive(this.path));
  }
  async pushFiles(...paths) {
    const files = paths.map((path7) => {
      const relativePath = relative(this.path, path7);
      return {
        content: fs3.readFileSync(path7),
        relativePath
      };
    }).filter((f) => !f.relativePath.includes("rag.json"));
    const body = files.map((f) => ({
      content: f.content.toString("base64"),
      rootKey: f.relativePath
    }));
    console.log("RAG: posting", files.map((f) => f.relativePath));
    const controller = new AbortController();
    const timeout = setTimeout(() => {
      console.log("timeout");
      controller.abort();
    }, 6e4);
    const response = await fetch2(this.url, {
      body: JSON.stringify(body),
      headers: {
        "Authorization": `Bearer ${this.apiKey}`,
        "Content-Type": "application/json"
      },
      method: "POST",
      signal: controller.signal
    });
    clearTimeout(timeout);
    if (!response.ok) {
      console.error("RAG: failed to post", response.status, response.statusText);
    }
    console.log("RAG: uploaded for processing");
  }
  watch() {
    this.watcher = new FileWatcher({ paths: [join3("**", "*")], root: this.path, allowedExtensions: ALLOWED_RAG_FILE_EXTENSIONS });
    this.watcher.onFileUpdate = (files) => {
      const liveFiles = files.filter((f) => !f.removed).map((f) => join3(this.path, f.relativePath));
      this.pushFiles(...liveFiles);
    };
    this.watcher.start();
  }
};

// src/commands/dev.ts
var createDev = (program) => {
  program.command("dev").description("Hot reload your code for remote chat debug").option("-l, --local", "(Soul Engine developers only) use a local soul engine server", false).option("--once", "Only post the code once, do not watch for changes", false).option("-n, --noopen", "Do not automatically open the browser", false).option("--id <id>", "Set the SoulId, otherwise assigns a UUID", uuidv4()).action(async ({ local, once, noopen, id }) => {
    await handleLogin(local);
    const globalConfig = await getConfig(local);
    const organization = globalConfig.get("organization");
    if (!organization) {
      throw new Error("missing organization, even after login");
    }
    const { default: open } = await import("open");
    let soulConfig;
    const optionalConfigPath = path3.join(process.cwd(), "soul-engine.json");
    if (existsSync2(optionalConfigPath)) {
      soulConfig = JSON.parse(readFileSync3(optionalConfigPath, { encoding: "utf8" }));
    } else {
      const packageJsonPath = path3.join(process.cwd(), "package.json");
      const packageJson = JSON.parse(readFileSync3(packageJsonPath, { encoding: "utf8" }));
      soulConfig = {
        soul: packageJson.name,
        paths: [
          "package.json",
          "soul"
        ]
      };
    }
    const apiKey = globalConfig.get("apiKey") || "TOOD: fix me";
    const watcher = new FilePoster({
      apiKey,
      paths: soulConfig.paths ?? ["."],
      root: soulConfig.path ?? ".",
      organizationSlug: organization,
      blueprint: soulConfig.soul,
      local
    });
    let resolve = () => {
    };
    const synedOncePromise = new Promise((r) => {
      resolve = r;
    });
    watcher.once("stateless", () => {
      if (once) {
        console.log("posted");
        resolve();
        return;
      }
      console.log("SoulId:", id);
      const url = local ? `http://localhost:3000/chats/${organization}/${soulConfig.soul}/${id}` : `https://souls.chat/chats/${organization}/${soulConfig.soul}/${id}`;
      console.log("debug chat available at", url);
      if (!noopen) {
        open(url);
      }
    });
    await watcher.start();
    if (once) {
      await synedOncePromise;
      return;
    }
    const keepAliveInterval = setInterval(() => {
    }, 60 * 1e3);
    const ragDirPath = path3.join(process.cwd(), "rag");
    if (existsSync2(ragDirPath)) {
      const ragFilePoster = RagPoster.createWithDefaultConfig({
        path: ragDirPath,
        organization,
        local,
        apiKey
      });
      ragFilePoster.watch();
    }
    return new Promise((resolve2) => {
      console.log("watching your files...");
      process.on("SIGINT", () => {
        console.log("Received SIGINT. Exiting.");
        clearInterval(keepAliveInterval);
        watcher.stop();
        resolve2();
      });
    });
  });
};
var dev_default = createDev;

// src/commands/init.ts
import { globSync } from "glob";
import Handlebars from "handlebars";
import { readFileSync as readFileSync4, renameSync, statSync, writeFileSync } from "node:fs";
import { join as join4, dirname as dirname2 } from "node:path";
import { fileURLToPath } from "node:url";
import fsExtra from "fs-extra";
var __filename = fileURLToPath(import.meta.url);
var __dirname = dirname2(__filename);
var templatePath = __dirname.endsWith("dist") ? join4(__dirname, "..", "template") : join4(__dirname, "..", "..", "template");
var createInit = (program) => {
  program.command("init <projectName>").description("Create a new soul for the OPEN SOULS soul engine.").option("-l, --local", "", false).action(async (projectName, options) => {
    await handleLogin(options.local);
    const config = await getConfig();
    if (!projectName) {
      console.log("missing project name");
      return;
    }
    const safeProjectName = projectName.replaceAll(/\s/g, "-").toLowerCase();
    const lowerCaseEntityName = safeProjectName.split("-")[0];
    const entityName = lowerCaseEntityName.charAt(0).toUpperCase() + lowerCaseEntityName.slice(1);
    const { $: $2 } = await import("execa");
    console.log("cloning template...");
    await fsExtra.copy(templatePath, safeProjectName);
    console.log("Template copied successfully.");
    process.chdir(join4(".", safeProjectName));
    await $2`git init`;
    const files = globSync(`${process.cwd()}/**/*`, { dot: true, ignore: "node_modules/**/*" });
    const organization = config.get("organization") || "public";
    console.log("using soul-engine organization:", organization);
    const data = {
      name: projectName,
      slug: safeProjectName,
      entityName
    };
    console.log("processing files...");
    for (const file of files) {
      try {
        if (file.includes("node_modules"))
          continue;
        if (file.includes("/.git/"))
          continue;
        const stat = statSync(file);
        if (stat.isDirectory())
          continue;
        const rawFile = readFileSync4(file, { encoding: "utf8" });
        const template = Handlebars.compile(rawFile);
        writeFileSync(file, template(data));
        if (file.includes("{{")) {
          const templateFileName = Handlebars.compile(file.replace("\\", "\\\\"));
          const newFileName = templateFileName(data);
          renameSync(file, newFileName);
        }
      } catch (error) {
        console.error("skipping...", file, error);
      }
    }
    console.log("npm install...");
    await $2`npm install`;
    console.log("success.");
    return;
  });
};
var init_default = createInit;

// src/commands/logout.ts
var createLogout = (program) => {
  program.command("logout").description("Logout of the Soul Engine to remove your api key and organization.").option("-l, --local", "use the local config file", false).action(async ({ local }) => {
    const globalConfig = await getConfig(local);
    globalConfig.set("apiKey", "");
    globalConfig.set("organization", "");
  });
};
var logout_default = createLogout;

// src/commands/login.ts
var createLogin = (program) => {
  program.command("login").description("Login to the Soul Engine to provide this CLI with an api key and organization.").option("-l, --local", "Use the local config file", false).action(async (options) => {
    await handleLogin(options.local, true);
  });
};
var login_default = createLogin;

// src/commands/rag/push.ts
var createRagPushCommand = (program) => {
  program.command("push <path>").description("Push your RAG files to your SOUL ENGINE bucket.").option("-l, --local", "use the local config file", false).action(async (ragPath, options) => {
    const { local } = options;
    await handleLogin(local);
    const globalConfig = await getConfig(local);
    const organization = globalConfig.get("organization");
    if (!organization) {
      throw new Error("missing organization, even after login");
    }
    const defaultRagDir = ragPath.join(".", "rag");
    const ragDir = ragPath || defaultRagDir;
    const poster = RagPoster.createWithDefaultConfig({
      path: ragDir,
      organization,
      local,
      apiKey: globalConfig.get("apiKey")
    });
    try {
      await poster.push();
    } catch (error) {
      console.error("there was an error posting your RAG files:", error);
      throw error;
    }
  });
};
var push_default = createRagPushCommand;

// src/commands/rag/watch.ts
import path4 from "node:path";
var createRagWatch = (program) => {
  program.command("watch <path>").description("Push your RAG files to your SOUL ENGINE bucket.").option("-l, --local", "use the local config file", false).action(async (ragPath, options) => {
    const { local } = options;
    await handleLogin(local);
    const globalConfig = await getConfig(local);
    const organization = globalConfig.get("organization");
    if (!organization) {
      throw new Error("missing organization, even after login");
    }
    const defaultRagDir = path4.join(".", "rag");
    const ragDir = ragPath || defaultRagDir;
    const poster = RagPoster.createWithDefaultConfig({
      path: ragDir,
      organization,
      local,
      apiKey: globalConfig.get("apiKey")
      // root: ragDir
    });
    const keepAliveInterval = setInterval(() => {
    }, 60 * 1e3);
    try {
      poster.watch();
      return new Promise((resolve) => {
        console.log("watching your rag files...");
        process.on("SIGINT", () => {
          console.log("Received SIGINT. Exiting.");
          clearInterval(keepAliveInterval);
          resolve();
        });
      });
    } catch (error) {
      console.error("there was an error posting your RAG files:", error);
      throw error;
    }
  });
};
var watch_default = createRagWatch;

// src/commands/rag/index.ts
var createRagCommand = (program) => {
  const subCommand = program.command("rag");
  push_default(subCommand);
  watch_default(subCommand);
  return program;
};
var rag_default = createRagCommand;

// src/commands/install.ts
import fsExtra3 from "fs-extra/esm";

// src/communityInstaller.ts
import { $ } from "execa";
import fsExtra2 from "fs-extra/esm";
import { writeFile } from "node:fs/promises";
import { dirname as dirname3, join as join5 } from "node:path";
var getCommunityRoot = (branch) => {
  return `https://raw.githubusercontent.com/opensouls/community/${branch}/library/`;
};
var fetchCommunityContent = async (branch, path7) => {
  console.log("looking for path", path7);
  const resp = await fetch(`https://api.github.com/repos/opensouls/community/contents/library/${path7}?ref=${branch}`, {
    headers: {
      "Accept": "application/vnd.github.v3+json"
    }
  });
  if (!resp.ok) {
    console.error("Failed to fetch", path7, resp);
    throw new Error("Failed to fetch: " + path7);
  }
  return resp.json();
};
var CommunityInstaller = class {
  constructor(userPath, branch) {
    this.userPath = userPath;
    this.branch = branch;
  }
  async install() {
    const directory = dirname3(this.userPath);
    switch (directory) {
      case "perceptionProcessors":
        return this.preprocessorInstall();
      case "pipelines":
        return this.pipelineInstall();
      default:
        return this.defaultInstall();
    }
  }
  async defaultInstall() {
    if (!this.userPath.endsWith(".ts")) {
      this.userPath = this.userPath + ".ts";
    }
    const data = await this.fetchFile(this.userPath);
    const directory = dirname3(this.userPath);
    await fsExtra2.mkdirp(join5("soul", directory));
    const destinationPath = join5("soul", this.userPath);
    await writeFile(destinationPath, data);
    console.log(`${this.userPath} has been installed successfully to ${destinationPath}`);
  }
  async preprocessorInstall() {
    if (!this.userPath.endsWith(".ts")) {
      this.userPath = this.userPath + ".ts";
    }
    const data = await this.fetchFile(this.userPath);
    const destinationPath = join5("soul", "perceptionProcessor.ts");
    await writeFile(destinationPath, data);
    console.log(`${this.userPath} has been installed successfully to ${destinationPath}`);
  }
  async pipelineInstall() {
    await $`npm install @opensouls/pipeline`;
    const directoryContents = await fetchCommunityContent(this.branch, this.userPath);
    console.log(directoryContents);
    await this.processPipelineDirectory(directoryContents, ".");
  }
  async processPipelineDirectory(contents, basePath) {
    for (const item of contents) {
      if (item.path === `library/${this.userPath}/README.md`) {
        continue;
      }
      const localPath = join5(basePath, item.path.replace(new RegExp(`^library/${this.userPath}`, "i"), ""));
      if (item.type === "file") {
        const fileData = await fetch(item.download_url);
        if (!fileData.ok) {
          console.error("Failed to download file", item.path);
          continue;
        }
        const fileContent = await fileData.text();
        await fsExtra2.mkdirp(dirname3(localPath));
        await writeFile(localPath, fileContent);
        console.log(`Remote ${item.path} written to ${localPath}`);
      } else if (item.type === "dir") {
        const resp = await fetch(item.url, {
          headers: {
            "Accept": "application/vnd.github.v3+json"
          }
        });
        if (!resp.ok) {
          console.error("Failed to fetch directory", item.path, resp.status, resp.statusText);
          throw new Error("Failed to fetch directory: " + item.path);
        }
        await this.processPipelineDirectory(await resp.json(), basePath);
      }
    }
  }
  async fetchFile(path7) {
    const url = getCommunityRoot(this.branch) + path7;
    const resp = await fetch(url);
    if (!resp.ok) {
      console.error("Failed to fetch package", path7);
      throw new Error("Failed to fetch package: " + path7);
    }
    return resp.text();
  }
};

// src/commands/install.ts
var createInstall = (program) => {
  program.command("install").argument("<packagePath...>", "The full path of the library package (eg cognitiveStep/externalDialog). You can specify multiple library packages.").option("-b,--branch <branch>", "The branch to install from", "main").description("install a community package from the OPEN SOULS community library found here https://github.com/opensouls/community/tree/main/library").action(async (packagePaths, { branch }) => {
    for (let packagePath of packagePaths) {
      if (!await fsExtra3.pathExists("soul")) {
        console.error("You must be in the root of a soul project to install a community package.");
        return;
      }
      const installer = new CommunityInstaller(packagePath, branch);
      await installer.install();
    }
  });
};
var install_default = createInstall;

// src/stores/pull.ts
import fsExtra4 from "fs-extra/esm";
import { readFileSync as readFileSync5, writeFileSync as writeFileSync2, readdirSync as readdirSync2 } from "node:fs";
import path5 from "node:path";

// src/stores/hash.ts
import { createHash } from "node:crypto";
var hashContent = (data) => {
  const hash = createHash("sha256");
  hash.update(data);
  return hash.digest("hex");
};

// src/stores/pull.ts
var StorePuller = class {
  constructor(opts) {
    this.opts = opts;
  }
  async pull() {
    const manifest = await this.fetchManifest();
    const files = manifest.entries;
    await fsExtra4.mkdirp(this.fileSystemPath());
    for (const file of Object.values(files)) {
      const filePath = path5.join(this.fileSystemPath(), file.key);
      if (fsExtra4.pathExistsSync(filePath)) {
        const fileContent = readFileSync5(filePath, "utf8");
        const localHash = hashContent(fileContent);
        if (localHash === file.contentHash) {
          console.log(`File ${file.key} is up to date`);
          continue;
        }
      }
      console.log(`fetching ${file.key}`);
      const resp = await this.fetchFile(file.key);
      const data = await resp.text();
      writeFileSync2(filePath, data);
    }
    const localFiles = readdirSync2(this.fileSystemPath());
    for (const localFile of localFiles) {
      if (!files[localFile]) {
        console.log(`deleting ${localFile} -- ${path5.join(this.fileSystemPath(), localFile)}`);
      }
    }
    console.log("your store is up to date from the server");
  }
  async fetchManifest() {
    const { apiKey } = this.opts;
    const url = this.url();
    const resp = await fetch(url, {
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json"
      }
    });
    if (!resp.ok) {
      console.error("Failed to fetch manifest", this.opts.bucketName, { url: this.url(), response: resp.status, statusText: resp.statusText });
      throw new Error("Failed to fetch manifest: " + this.opts.bucketName);
    }
    return resp.json();
  }
  fetchFile(key) {
    const { apiKey } = this.opts;
    const url = this.url() + "/" + key;
    return fetch(url, {
      headers: {
        "Authorization": `Bearer ${apiKey}`
      }
    });
  }
  fileSystemPath() {
    if (this.opts.blueprint) {
      return path5.join(".", "stores", this.opts.bucketName);
    }
    return path5.join(".", "stores", "organization", this.opts.bucketName);
  }
  url() {
    const { organizationSlug, local } = this.opts;
    const rootUrl = local ? "http://localhost:4000/api" : "https://servers.souls.chat/api";
    if (this.opts.blueprint) {
      return `${rootUrl}/${organizationSlug}/stores/${this.opts.blueprint}/${this.opts.bucketName}`;
    }
    return `${rootUrl}/${organizationSlug}/stores/${this.opts.bucketName}`;
  }
};

// src/commands/stores/pull.ts
var createStoresPullCommand = (program) => {
  program.command("pull <bucketName>").description("Pull a specific bucket from the store. This can be in the format `:bucketName` for blueprint stores or `organization/:bucketName` for organization stores.").option("-l, --local", "Use the local configuration", false).action(async (bucketName, options) => {
    const { local } = options;
    console.log(`Pulling blueprint store '${bucketName}' from the store.`);
    await handleLogin(local);
    const globalConfig = await getConfig(local);
    const organizationSlug = globalConfig.get("organization");
    if (!organizationSlug) {
      throw new Error("missing organization, even after login");
    }
    if (bucketName.startsWith("organization/")) {
      const puller2 = new StorePuller(
        {
          organizationSlug,
          apiKey: globalConfig.get("apiKey"),
          local,
          bucketName: bucketName.split("/")[1]
        }
      );
      return await puller2.pull();
    }
    const blueprint = parsedPackageJson().name;
    const puller = new StorePuller(
      {
        organizationSlug,
        apiKey: globalConfig.get("apiKey"),
        local,
        blueprint,
        bucketName
      }
    );
    await puller.pull();
  });
};
var pull_default = createStoresPullCommand;

// src/stores/push.ts
import { readFileSync as readFileSync6, readdirSync as readdirSync3 } from "node:fs";
import path6 from "node:path";
var StorePusher = class {
  constructor(opts) {
    this.opts = opts;
  }
  async push() {
    const manifest = await this.fetchManifest();
    const files = manifest.entries;
    const localFiles = readdirSync3(this.fileSystemPath());
    for (const localFile of localFiles) {
      const filePath = path6.join(this.fileSystemPath(), localFile);
      const fileContent = readFileSync6(filePath, "utf-8");
      const localHash = hashContent(fileContent);
      if (!files[localFile] || files[localFile].contentHash !== localHash) {
        console.log(`pushing ${localFile}`);
        await this.pushFile(localFile, fileContent);
      }
    }
    for (const fileKey in files) {
      if (!localFiles.includes(fileKey)) {
        console.log(`deleting ${fileKey} from server`);
        await this.deleteFile(fileKey);
      }
    }
    console.log("your store is up to date on the server");
  }
  async fetchManifest() {
    const { apiKey } = this.opts;
    const url = this.url();
    const resp = await fetch(url, {
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json"
      }
    });
    if (!resp.ok) {
      console.error("Failed to fetch manifest", this.opts.bucketName, { url: this.url(), response: resp.status, statusText: resp.statusText });
      throw new Error("Failed to fetch manifest: " + this.opts.bucketName);
    }
    return resp.json();
  }
  pushFile(key, content) {
    const { apiKey } = this.opts;
    const url = this.url();
    return fetch(url, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        key,
        content
      })
    });
  }
  deleteFile(key) {
    const { apiKey } = this.opts;
    const url = this.url() + "/" + key;
    return fetch(url, {
      method: "DELETE",
      headers: {
        "Authorization": `Bearer ${apiKey}`
      }
    });
  }
  fileSystemPath() {
    if (this.opts.blueprint) {
      return path6.join(".", "stores", this.opts.bucketName);
    }
    return path6.join(".", "stores", "organization", this.opts.bucketName);
  }
  url() {
    const { organizationSlug, local } = this.opts;
    const rootUrl = local ? "http://localhost:4000/api" : "https://servers.souls.chat/api";
    if (this.opts.blueprint) {
      return `${rootUrl}/${organizationSlug}/stores/${this.opts.blueprint}/${this.opts.bucketName}`;
    }
    return `${rootUrl}/${organizationSlug}/stores/${this.opts.bucketName}`;
  }
};

// src/commands/stores/push.ts
var createStoresPushCommand = (program) => {
  program.command("push <bucketName>").description("Push a specific bucket to the store. This can be in the format `:bucketName` for blueprint stores or `organization/:bucketName` for organization stores.").option("-l, --local", "Use the local configuration", false).action(async (bucketName, options) => {
    const { local } = options;
    console.log(`Pushing blueprint store '${bucketName}' to the store.`);
    await handleLogin(local);
    const globalConfig = await getConfig(local);
    const organizationSlug = globalConfig.get("organization");
    if (!organizationSlug) {
      throw new Error("missing organization, even after login");
    }
    if (bucketName.startsWith("organization/")) {
      const pusher2 = new StorePusher(
        {
          organizationSlug,
          apiKey: globalConfig.get("apiKey"),
          local,
          bucketName: bucketName.split("/")[1]
        }
      );
      return await pusher2.push();
    }
    const blueprint = parsedPackageJson().name;
    const pusher = new StorePusher(
      {
        organizationSlug,
        apiKey: globalConfig.get("apiKey"),
        local,
        blueprint,
        bucketName
      }
    );
    await pusher.push();
  });
};
var push_default2 = createStoresPushCommand;

// src/commands/stores/index.ts
var createStoreCommand = (program) => {
  const subCommand = program.command("stores");
  pull_default(subCommand);
  push_default2(subCommand);
  return program;
};
var stores_default = createStoreCommand;

// src/customModels/customModel.ts
import fetch3 from "node-fetch";
var CustomModelManager = class {
  constructor(local, organizationSlug, apiKey) {
    this.local = local;
    this.organizationSlug = organizationSlug;
    this.globalConfig = { get: (key) => key === "apiKey" ? apiKey : null };
    this.rootUrl = this.local ? "http://localhost:4000/api" : "https://servers.souls.chat/api";
  }
  async listModels() {
    const url = `${this.rootUrl}/${this.organizationSlug}/customProcessors`;
    try {
      const response = await fetch3(url, {
        headers: {
          "Authorization": `Bearer ${this.globalConfig.get("apiKey")}`,
          "Content-Type": "application/json"
        }
      });
      if (!response.ok) {
        console.error("Failed to fetch custom processors", { url, response: response.status, statusText: response.statusText });
        return;
      }
      const processors = await response.json();
      return processors;
    } catch (error) {
      console.error("Error fetching custom processors:", error);
    }
  }
  async createModel(modelData) {
    const url = `${this.rootUrl}/${this.organizationSlug}/customProcessors`;
    try {
      const response = await fetch3(url, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.globalConfig.get("apiKey")}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(modelData)
      });
      if (!response.ok) {
        console.error("Failed to create custom model", { url, response: response.status, statusText: response.statusText });
        return;
      }
      const newProcessor = await response.json();
      return newProcessor;
    } catch (error) {
      console.error("Error creating custom processor:", error);
    }
  }
};
var customModel_default = CustomModelManager;

// src/commands/custom-models/list.ts
import Table from "cli-table3";
var createListModelsCommand = (program) => {
  program.command("list").description("List custom models for the organization").option("-l, --local", "(Soul Engine Dev Only) Use a local soul engine instance instead of production", false).action(async ({ local }) => {
    console.log(`Listing custom models for the organization.`);
    await handleLogin(local);
    const globalConfig = await getConfig(local);
    const organizationSlug = globalConfig.get("organization");
    if (!organizationSlug) {
      throw new Error("missing organization, even after login");
    }
    const customModelManager = new customModel_default(local, organizationSlug, globalConfig.get("apiKey"));
    const models = await customModelManager.listModels();
    const table = new Table({
      head: ["Name", "API Endpoint", "Model Name"]
    });
    table.push(...models.map((model) => [model.name, model.api_endpoint, model.model_name]));
    console.log(table.toString());
  });
  return program;
};
var list_default = createListModelsCommand;

// src/commands/custom-models/createModel.ts
import inquirer from "inquirer";
var createCreateModelCommand = (program) => {
  program.command("create").description("Create a custom model for the organization").option("-l, --local", "(Soul Engine dev only) use a local soul engine server", false).action(async ({ local }) => {
    console.log(`Creating a custom model for the organization.`);
    await handleLogin(local);
    const globalConfig = await getConfig(local);
    const organizationSlug = globalConfig.get("organization");
    if (!organizationSlug) {
      throw new Error("missing organization, even after login");
    }
    const answers = await inquirer.prompt([
      {
        type: "input",
        name: "name",
        message: "The name of your custom model. This is the name you'll use to access the model."
      },
      {
        type: "input",
        name: "apiEndpoint",
        message: "The baseUrl for the model (eg https://api.fireworks.ai/inference/v1 )"
      },
      {
        type: "password",
        name: "apiKey",
        message: "The API key for the model"
      },
      {
        type: "input",
        name: "modelName",
        message: "What is the provider's model name? (eg. 'gpt-4o')"
      },
      {
        type: "confirm",
        name: "confirmCreation",
        message: "Do you want to create this model?",
        default: false
      }
    ]);
    const customModelManager = new customModel_default(local, organizationSlug, globalConfig.get("apiKey"));
    const newModel = await customModelManager.createModel(answers);
    console.log("New model created:", newModel);
  });
  return program;
};
var createModel_default = createCreateModelCommand;

// src/commands/custom-models/index.ts
var createCustomModelCommand = (program) => {
  const subCommand = program.command("custom-models");
  list_default(subCommand);
  createModel_default(subCommand);
  return program;
};
var custom_models_default = createCustomModelCommand;

// src/commands/index.ts
var setupCLI = (program) => {
  apikey_default(program);
  dev_default(program);
  init_default(program);
  login_default(program);
  logout_default(program);
  rag_default(program);
  stores_default(program);
  install_default(program);
  custom_models_default(program);
};

// src/index.ts
var run = () => {
  const program = new Command();
  setupCLI(program);
  return program.parseAsync();
};
export {
  run
};
//# sourceMappingURL=index.mjs.map
